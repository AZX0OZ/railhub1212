-- ds: https://discord.gg/67UTqK8su5
print(321)
-- tg: https://t.me/+iAxwlFrbUsBiNzli

 -- ###############            ###           ###   ###              ###          ###   ###        ###   ############                      
 -- ###          ###          #####          ###   ###              ###          ###   ###        ###   ###       ###                         
 -- ###          ###         ### ###               ###              ###          ###   ###        ###   ###       ###              
 -- ###        ###          ###   ###        ###   ###              ###          ###   ###        ###   ############                          
 -- ############           ###     ###       ###   ###              ################   ###        ###   ###        ###                                  
 -- ###       ###         #############      ###   ###              ################   ###        ###   ###         ###                   
 -- ###        ###       ###         ###     ###   ###              ###          ###   ###        ###   ###         ###                              
 -- ###         ###     ###           ###    ###   ##############   ###          ###    ############    ###         ###                         
 -- ###          ###   ###             ###   ###   ##############   ###          ###     ##########     ##############                                               
----------------------------------------------------------------------------------------------------------------------
 ---------------------------------------------------------------------------------------------------------------------
 ---------------------------------------------------------------------------------------------------------------------
 ---------------------------------------------------------------------------------------------------------------------
 ---------------------------------------------------------------------------------------------------------------------
 ---------------------------------------------------------------------------------------------------------------------
 ---------------------------------------------------------------------------------------------------------------------
 ---------------------------------------------------------------------------------------------------------------------

--[[
    Protected | Secure by GhostyDuckyy#7698
]]--

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Players           = game:GetService("Players")
local RunService        = game:GetService("RunService")
local UserInputService  = game:GetService("UserInputService")
local TweenService      = game:GetService("TweenService")
local TeleportService   = game:GetService("TeleportService")
local Lighting          = game:GetService("Lighting")
local Workspace         = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager") -- Adding VirtualInputManager for key press simulation

local Window = Rayfield:CreateWindow({
    Name = "RAILhub - Army Roblox RP",
    LoadingTitle = "RAILhub",
    LoadingSubtitle = "by SREE",
    ConfigurationSaving = {
        Enabled = false,
        FolderName = "RAILhubConfig",
        FileName = "Config"
    },
    KeySystem = false,
    KeySettings = {
        Title = "RAILhub",
        Subtitle = "Key System",
        Note = "Join the discord (discord.gg/sirius)",
        FileName = "SiriusKey",
        SaveKey = true,
        GrabKeyFromSite = false,
        Key = "Hello"
    },
    Discord = {
        Enabled = false,
        Invite = "https://discord.gg/67UTqK8su5",
        RememberJoins = true
    }
})

local function moveToPoint(hrp, startCFrame, targetCFrame, duration)
    local startTime = tick()
    while tick() - startTime < duration do
        local progress = math.min(1, (tick() - startTime) / duration)
        local alpha = math.sin(progress * math.pi / 2)
        hrp.CFrame = startCFrame:Lerp(targetCFrame, alpha)
        hrp.Velocity = Vector3.new(0, 0, 0)
        hrp.RotVelocity = Vector3.new(0, 0, 0)
        task.wait(0)
    end
end

local function smoothTeleport(targetPos)
    local player = Players.LocalPlayer
    local character = player and player.Character
    if not character then return end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    -- Direct teleportation
    Rayfield:Notify({
        Title = "Teleportation",
        Content = "Teleporting...",
        Duration = 1.5,
        Image = 6035190846
    })

    hrp.CFrame = CFrame.new(targetPos)
    hrp.Velocity = Vector3.new(0, 0, 0)
    hrp.RotVelocity = Vector3.new(0, 0, 0)
    


    -- Don't delete!
    --[[ Old underground movement method (disabled)
    local startPos = hrp.Position
    local undergroundY = -30

    local midPoint1 = Vector3.new(startPos.X, undergroundY, startPos.Z)
    local midPoint2 = Vector3.new(targetPos.X, undergroundY, targetPos.Z)
    local finalPoint = Vector3.new(targetPos.X, targetPos.Y, targetPos.Z)

    Rayfield:Notify({
        Title = "Teleportation",
        Content = "Starting movement...",
        Duration = 1.5,
        Image = 6035190846
    })

    moveToPoint(hrp, hrp.CFrame, CFrame.new(midPoint1), 0.3) -- descent underground
    moveToPoint(hrp, CFrame.new(midPoint1), CFrame.new(midPoint2), 0.5) -- movement underground

    if targetPos.Y > midPoint2.Y then
        local midPoint3 = Vector3.new(targetPos.X, targetPos.Y + 10, targetPos.Z)
        moveToPoint(hrp, CFrame.new(midPoint2), CFrame.new(midPoint3), 0.3) -- rise above target
        moveToPoint(hrp, CFrame.new(midPoint3), CFrame.new(finalPoint), 0.2) -- descent to target
    else
        moveToPoint(hrp, CFrame.new(midPoint2), CFrame.new(finalPoint), 0.3) -- direct rise to target
    end

    hrp.CFrame = CFrame.new(finalPoint)
    hrp.Velocity = Vector3.new(0, 0, 0)
    hrp.RotVelocity = Vector3.new(0, 0, 0)
    ]]--
end

local InfoTab = Window:CreateTab("Information", 7733960981)

InfoTab:CreateSection("Updates")
InfoTab:CreateLabel("Last update: 10.05.2025!")
InfoTab:CreateLabel("v 0.6.0.0!")

InfoTab:CreateButton({
    Name = "Discord Link",
    Callback = function()
        setclipboard("https://discord.gg/67UTqK8su5")
        Rayfield:Notify({
            Title = "Discord",
            Content = "Link copied to clipboard!",
            Duration = 3,
            Image = 7733978098
        })
    end,
})

InfoTab:CreateButton({
    Name = "Telegram Link",
    Callback = function()
        setclipboard("https://t.me/+iAxwlFrbUsBiNzli")
        Rayfield:Notify({
            Title = "Telegram",
            Content = "Link copied to clipboard!",
            Duration = 3,
            Image = 7733978098
        })
    end,
})

local TeleportTab = Window:CreateTab("Teleport", 6035190846)
if TeleportTab then
    TeleportTab:CreateSection("Points of Interest")
end

local function CreateStyledTeleportButton(name, position)
    TeleportTab:CreateButton({
        Name = name,
        Info = "Click to teleport",
        Interact = "Teleport",
        CurrentValue = false,
        Flag = "Teleport_" .. name:gsub("%s+", "_"),
        Callback = function()
            smoothTeleport((typeof(position) == "CFrame") and position.Position or position)
        end
    })
end

local teleports = {
    {name = "Coffee Shop", pos = CFrame.new(1510.12548828125, 3, -50.033023834228516)},
    {name = "Police Post", pos = CFrame.new(1880.78711, 3.02372599, -79.1625366)},
    {name = "Gas Station", pos = CFrame.new(1611.48291, 3.68000031, 193.309387)},
    {name = "FSB Post", pos = CFrame.new(2594.14526, 2.96875048, -213.897064)},
    {name = "Checkpoint-1", pos = CFrame.new(1093.0481, 40.9999924, -59.7594757)},
    {name = "Checkpoint-2", pos = CFrame.new(1305.15637, 16.7970123, -66.1204681)},
    {name = "Village", pos = CFrame.new(2578.659912109375, 3.050001621246338, 48.234134674072266)},
    {name = "Parade Ground", pos = CFrame.new(33.97133255004883, 3.0999984741210938, -13.471328735351562)},
    {name = "Airborne", pos = CFrame.new(214.971634, 2.96874952, -79.2867432)},
    {name = "HQ", pos = CFrame.new(-365.19281, 3.06999874, 67.8806)},
    {name = "Military Police", pos = CFrame.new(-397.532074, 3.0687499, 334.057129)},
    {name = "Canteen", pos = CFrame.new(86.8922577, 4.24000216, 235.584213)},
    {name = "Smugglers Base", pos = CFrame.new(665.766357, 26.5687485, -708.443604)},
    {name = "Bushes at CP-1", pos = CFrame.new(457.5315, 12.9999, -43.6891)},
    {name = "Mercenaries Base", pos = CFrame.new(826.204346, 2.96875048, -1223.91553)},
    {name = "Tower at CP-1", pos = CFrame.new(590.221, 140.583, 292.378)},
    {name = "Freddy Bear", pos = CFrame.new(3982.34155, 40.9999847, -73.8225555)}
}

for _, teleport in ipairs(teleports) do
    CreateStyledTeleportButton(teleport.name, teleport.pos)
end

CreateStyledTeleportButton("AFK Zone", CFrame.new(1196.45837, -7.10957336, -2100.12256))

local FarmTab = Window:CreateTab("Farm", 4483345737)
FarmTab:CreateSection("Drop")

local espDropEnabled    = false
local espDropConnection = nil
local ESPFolder         = nil
local dropCache         = {}
local updateInterval    = 0.5 
local lastUpdate        = 0

-- Creating a new ESP system for drops based on the player ESP system
local DropESP = {
    Enabled = false,
    Boxes = true,
    Names = true,
    Color = Color3.fromRGB(255, 0, 0),  -- Red color for drops
    Transparency = 1,
    MaxDistance = 10000,
    RainbowColor = false,
    TextSize = 15,
    TargetFolder = nil,
    UseDrawing = false,  -- Using BillboardGui by default
    Rainbow = {
        Speed = 1,
        Phase = 0
    }
}

-- DropESPObject for managing individual drop ESP elements
local DropESPObject = {}
DropESPObject.__index = DropESPObject

-- Looking for the GetRelativePosition function and adding protection against nil values
local function GetRelativePosition(position)
    if not position then return Vector2.new(0, 0), false, 0 end
    
    local localPlayer = Players.LocalPlayer
    local character = localPlayer and localPlayer.Character
    local localRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    local success, result = pcall(function()
        local screenPos, onScreen = Workspace.CurrentCamera:WorldToViewportPoint(position)
        local dist = localRootPart and (localRootPart.Position - position).Magnitude or screenPos.Z
        return {screenPos, onScreen, dist} -- Returning a table for easier verification
    end)
    
    if success and type(result) == "table" and #result == 3 then
        local screenPos = result[1]
        local onScreen = result[2]
        local dist = result[3]

        -- Fixing type checking for screenPos
        if type(screenPos) == "vector" and type(onScreen) == "boolean" and type(dist) == "number" then
            return Vector2.new(screenPos.X, screenPos.Y), onScreen, dist
        else
            -- If types are incorrect, log and return default values
            print("[DEBUG] GetRelativePosition: Type mismatch in pcall result. screenPos:", type(screenPos), "onScreen:", type(onScreen), "dist:", type(dist))
            return Vector2.new(0, 0), false, 0
        end
    else
        -- If pcall failed or returned unexpected results
        print("[DEBUG] GetRelativePosition: pcall failed or returned unexpected result. Success:", success, "Result:", result)
        return Vector2.new(0, 0), false, 0
    end
end

-- Checking if the CreateDrawing function exists from the player ESP system
local function SafeCreateDrawing(drawingType, properties)
    if not Drawing then
        Rayfield:Notify({
            Title = "ESP Error",
            Content = "Drawing library not found!",
            Duration = 3,
            Image = 4483345998
        })
        return nil
    end
    
    local success, drawing = pcall(function()
        local draw = Drawing.new(drawingType)
        for prop, value in pairs(properties) do
            draw[prop] = value
        end
        return draw
    end)
    
    if success then
        return drawing
    else
        Rayfield:Notify({
            Title = "ESP Error",
            Content = "Error creating " .. drawingType .. ": " .. tostring(drawing),
            Duration = 3,
            Image = 4483345998
        })
        return nil
        end
    end

-- Completely rewriting DropESPObject.new to use SafeCreateDrawing
function DropESPObject.new(dropPart)
    if not dropPart then return nil end
    
    local self = setmetatable({}, DropESPObject)
    self.Part = dropPart
    
    -- Creating Box (square around the object)
    local outlineBox = SafeCreateDrawing("Square", {
        Thickness = 3,
        Color = Color3.new(0, 0, 0),
        Transparency = 1,
        Filled = false,
        Visible = false
    })
    
    local mainBox = SafeCreateDrawing("Square", {
        Thickness = 1,
        Color = DropESP.Color,
        Transparency = 1,
        Filled = false,
        Visible = false
    })
    
    if not outlineBox or not mainBox then
        -- If failed to create boxes, return nil
        if outlineBox then outlineBox:Remove() end
        if mainBox then mainBox:Remove() end
        return nil
    end
    
    self.Box = {
        Outline = outlineBox,
        Main = mainBox
    }
    
    -- Creating text label
    local nameLabel = SafeCreateDrawing("Text", {
        Text = "drop",
        Size = DropESP.TextSize,
        Center = true,
        Outline = true,
        OutlineColor = Color3.new(0, 0, 0),
        Color = DropESP.Color,
        Visible = false,
        Font = Drawing.Fonts and Drawing.Fonts.System or 1
    })
    
    if not nameLabel then
        -- If failed to create text, remove boxes and return nil
        outlineBox:Remove()
        mainBox:Remove()
        return nil
    end
    
    self.Name = nameLabel
    
    return self
end

-- Updating the Update function to check existence of all objects
function DropESPObject:Update()
    -- Checking if all necessary objects exist
    if not self.Part or not self.Part.Parent or not self.Box or not self.Box.Outline or 
       not self.Box.Main or not self.Name or not DropESP.Enabled then
        self:Hide()
        return
    end
    
    -- Safely getting drop position on screen
    local dropPos
    pcall(function()
        dropPos = self.Part.Position
    end)
    
    if not dropPos then
        self:Hide()
        return
    end
    
    -- Getting position on screen
    local pos2D, onScreen, distance
    pcall(function()
        pos2D, onScreen, distance = GetRelativePosition(dropPos)
    end)
    
    -- Checking validity of results
    if not pos2D or not onScreen or not distance or distance > DropESP.MaxDistance then
        self:Hide()
        return
    end
    
    -- Determining ESP color
    local espColor = DropESP.Color
    
    if DropESP.RainbowColor then
        espColor = UpdateRainbowColor(DropESP.Rainbow.Phase)
        DropESP.Rainbow.Phase = (DropESP.Rainbow.Phase + DropESP.Rainbow.Speed) % 360
    end
    
    -- Calculating box size based on distance
    local size = math.clamp(40 - distance / 30, 15, 30)
    local boxSize = Vector2.new(size, size)
    local boxPosition = Vector2.new(pos2D.X - size/2, pos2D.Y - size/2)
    
    -- Handling boxes
    if DropESP.Boxes then
        pcall(function()
            self.Box.Outline.Size = boxSize
            self.Box.Outline.Position = boxPosition
            self.Box.Outline.Visible = true
            self.Box.Outline.Transparency = DropESP.Transparency
            
            self.Box.Main.Size = boxSize
            self.Box.Main.Position = boxPosition
            self.Box.Main.Color = espColor
            self.Box.Main.Visible = true
            self.Box.Main.Transparency = DropESP.Transparency
        end)
    else
        pcall(function()
            self.Box.Outline.Visible = false
            self.Box.Main.Visible = false
        end)
    end
    
    -- Handling name with distance format "drop[x]"
    if DropESP.Names then
        pcall(function()
            self.Name.Text = string.format("drop[%d]", math.floor(distance))
            self.Name.Position = Vector2.new(pos2D.X, pos2D.Y - size/2 - 15)
            self.Name.Color = espColor
            self.Name.Visible = true
            self.Name.Transparency = DropESP.Transparency
        end)
    else
        pcall(function()
            self.Name.Visible = false
        end)
    end
end

-- Updating the Hide function
function DropESPObject:Hide()
    pcall(function()
        if self.Box and self.Box.Outline then self.Box.Outline.Visible = false end
        if self.Box and self.Box.Main then self.Box.Main.Visible = false end
        if self.Name then self.Name.Visible = false end
    end)
end

-- Updating the Remove function
function DropESPObject:Remove()
    pcall(function() self:Hide() end)
    
    pcall(function() if self.Box and self.Box.Outline then self.Box.Outline:Remove() end end)
    pcall(function() if self.Box and self.Box.Main then self.Box.Main:Remove() end end)
    pcall(function() if self.Name then self.Name:Remove() end end)
    
    self.Part = nil
    self.Box = nil
    self.Name = nil
end

-- Manager for managing all ESP drop objects
local DropESPManager = { Objects = {} }

-- Updating the CreateObject function in DropESPManager to handle nil-objects
function DropESPManager:CreateObject(dropPart)
    if not dropPart then return end
    
    if self.Objects[dropPart] then
        self:RemoveObject(dropPart)
    end
    
    local espObject = DropESPObject.new(dropPart)
    if espObject then
        self.Objects[dropPart] = espObject
    end
end

function DropESPManager:RemoveObject(dropPart)
    if self.Objects[dropPart] then
        self.Objects[dropPart]:Remove()
        self.Objects[dropPart] = nil
    end
end

-- Function to find model by specified coordinates
local function FindDropModelByCoordinates()
    -- Coordinates to search for model
    local targetPos = Vector3.new(402.388428, 0.330908775, 203.474518)
    local targetCFrame = CFrame.new(
        402.388428, 0.330908775, 203.474518,
        -0.499959469, 0, -0.866048813, 
        0, 1, 0, 
        0.866048813, 0, -0.499959469
    )
    
    -- Searching for model nearby specified coordinates
    local closestModel = nil
    local closestDistance = 5 -- Maximum search distance
    
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") or obj:IsA("Model") then
            local objPos
            if obj:IsA("Model") and obj:FindFirstChild("PrimaryPart") then
                objPos = obj.PrimaryPart.Position
            elseif obj:IsA("BasePart") then
                objPos = obj.Position
            else
                continue
            end
            
            local distance = (objPos - targetPos).Magnitude
            if distance < closestDistance then
                closestDistance = distance
                closestModel = obj
            end
        end
    end
    
    return closestModel
end

-- Function to find drop folder
local function FindDropFolder()
    -- If already found folder, return it
    if DropESP.TargetFolder then
        return DropESP.TargetFolder
    end
    
    local targetModel = FindDropModelByCoordinates()
    if not targetModel then
        return nil
    end
    
    -- Finding parent folder of model
    local folder = targetModel
    while folder and folder.Parent ~= Workspace do
        folder = folder.Parent
    end
    
    if folder and folder.Parent == Workspace then
        DropESP.TargetFolder = folder
            Rayfield:Notify({
                Title = "ESP Drop",
                Content = "Found drop folder: " .. folder.Name,
                Duration = 3,
                Image = 4483345998
            })
        return folder
    else
        Rayfield:Notify({
            Title = "ESP Drop",
            Content = "Could not find drop folder",
            Duration = 3,
            Image = 4483345998
        })
        return nil
    end
end

-- Function to check if model has PrimaryPart or main part
local function GetModelMainPart(model)
    if not model then return nil end

    if model:IsA("Model") then
        -- Checking for PrimaryPart
        if model.PrimaryPart and model.PrimaryPart:IsA("BasePart") and model.PrimaryPart.Transparency < 0.9 then
            return model.PrimaryPart
        end
        
        -- Trying to find any BasePart in model (including nested)
        for _, child in pairs(model:GetDescendants()) do
            if child:IsA("BasePart") and child.Transparency < 0.9 then
                return child
            end
        end
    elseif model:IsA("BasePart") and model.Transparency < 0.9 then
        return model
    end
    
    return nil
end

function DropESPManager:UpdateAll()
    -- No longer searching for folder here, using already found one
    
    -- Updating existing objects
    for part, objData in pairs(self.Objects) do
        if part and part.Parent then
            if objData.Type == "Drawing" and objData.Object then
                objData.Object:Update()
            elseif objData.Type == "BillboardGui" and objData.Object then
                if not UpdateBillboardESP(objData.Object) then
                    self:RemoveObject(part)
                end
            end
        else
            self:RemoveObject(part)
        end
    end
    
    -- Поиск новых дропов, если ESP включен и папка найдена
    if DropESP.Enabled and DropESP.TargetFolder then
        local foundCount = 0
        
        -- Перебираем непосредственных потомков папки (без глубокого поиска)
        for _, model in pairs(DropESP.TargetFolder:GetChildren()) do
            -- Проверяем только объекты, которые являются моделями
            if model:IsA("Model") then
                local mainPart = GetModelMainPart(model)
                
                if mainPart and not self.Objects[mainPart] then
                    self:CreateObject(mainPart)
                    foundCount = foundCount + 1
                end
            end
        end
    end
end

-- Добавляю глобальную переменную для хранения соединения проверки прозрачности
_G.TransparencyCheckConnection = nil

-- Функция для проверки прозрачности объектов и обновления их видимости
local function CheckTransparency()
    if not DropESP.TargetFolder or not DropESP.Enabled then return end
    
    -- Проверяем существующие объекты на прозрачность
    for part, objData in pairs(DropESPManager.Objects) do
        if part and part.Parent then
            -- Проверяем прозрачность объекта
            if part:IsA("BasePart") and part.Transparency >= 0.9 then
                -- Если объект стал прозрачным, удаляем его ESP
                DropESPManager:RemoveObject(part)
            end
        end
    end
    
    -- Проверяем объекты в папке на наличие новых видимых
    if DropESP.TargetFolder then
        for _, model in pairs(DropESP.TargetFolder:GetChildren()) do
            if model:IsA("Model") then
                local mainPart = GetModelMainPart(model)
                
                -- Проверяем, что часть видима (прозрачность < 0.9) и ещё не добавлена
                if mainPart and mainPart:IsA("BasePart") and 
                   mainPart.Transparency < 0.9 and 
                   not DropESPManager.Objects[mainPart] then
                    DropESPManager:CreateObject(mainPart)
                end
            end
        end
    end
end

-- Изменяю функцию включения ESP, чтобы она запускала периодическую проверку прозрачности
FarmTab:CreateToggle({
    Name = "ESP Boxes",
    CurrentValue = false,
    Flag = "DropESPEnabled",
    Callback = function(Value)
        DropESP.Enabled = Value
        _G.ESPNotifiedAfterFind = false
        
        if Value then
            -- Больше не ищем папку при включении
            if not _G.DropESPUpdateConnection then
                _G.DropESPUpdateConnection = RunService.RenderStepped:Connect(function()
                    local success, err = pcall(function()
                        DropESPManager:UpdateAll()
                    end)
                    
                    if not success and not _G.ESPErrorNotified then
                        -- Убираю уведомление об ошибке ESP
                        _G.ESPErrorNotified = true
                        task.delay(10, function() _G.ESPErrorNotified = false end)
                    end
                end)
            end
            
            -- Запускаем проверку прозрачности каждую секунду
            if not _G.TransparencyCheckConnection then
                _G.TransparencyCheckConnection = task.spawn(function()
                    while DropESP.Enabled do
                        pcall(CheckTransparency)
                        task.wait(1) -- Проверка каждую секунду
                    end
                end)
            end
        else
            if _G.DropESPUpdateConnection then
                _G.DropESPUpdateConnection:Disconnect()
                _G.DropESPUpdateConnection = nil
            end
            
            -- Останавливаем проверку прозрачности
            if _G.TransparencyCheckConnection then
                task.cancel(_G.TransparencyCheckConnection)
                _G.TransparencyCheckConnection = nil
            end
            
            -- Удаляем все объекты ESP при отключении
            DropESPManager:ClearAllObjects()
            
            -- Больше не сбрасываем папку при отключении
        end
    end
})

FarmTab:CreateButton({
    Name = "pick up nearest box",
    Callback = function()
        -- Ищем ближайший бокс
        local player = Players.LocalPlayer
        local character = player and player.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        -- Сохраняем исходную позицию для возврата
        local originalPosition = hrp.Position
        local originalCFrame = hrp.CFrame
        
        -- Ищем все возможные папки с боксами
        local potentialFolders = {
            Workspace:FindFirstChild("CaseDrops"),
            DropESP.TargetFolder, -- Используем уже найденную папку из ESP
            Workspace:FindFirstChild("Cases"),
            Workspace:FindFirstChild("Drops")
        }
        
        local closestDrop = nil
        local closestDistance = math.huge
        local proximityPrompt = nil
        
        -- Ищем ближайший бокс во всех потенциальных папках
        for _, folder in pairs(potentialFolders) do
            if folder then
                for _, obj in pairs(folder:GetDescendants()) do
                    if obj:IsA("BasePart") and obj.Transparency < 0.9 then
                        -- Это может быть часть бокса
                        local distance = (hrp.Position - obj.Position).Magnitude
                    if distance < closestDistance then
                            -- Проверяем наличие ProximityPrompt
                            local prompt = obj:FindFirstChildOfClass("ProximityPrompt")
                            if prompt then
                                proximityPrompt = prompt
                                closestDrop = obj
                        closestDistance = distance
                            else
                                -- Проверяем в родительской модели
                                local model = obj:FindFirstAncestorOfClass("Model")
                                if model then
                                    prompt = model:FindFirstChildWhichIsA("ProximityPrompt", true)
                                    if prompt then
                                        proximityPrompt = prompt
                                        closestDrop = obj
                                        closestDistance = distance
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        
        if not closestDrop then
            -- Если не нашли в папках, попробуем поискать по всей рабочей области
            for _, obj in pairs(Workspace:GetDescendants()) do
                if (obj.Name == "Union" or obj.Name:find("Case") or obj.Name:find("Box") or obj.Name:find("Drop")) 
                   and obj:IsA("BasePart") and obj.Transparency < 0.9 then
                    local distance = (hrp.Position - obj.Position).Magnitude
                    if distance < closestDistance then
                        -- Проверяем наличие ProximityPrompt вокруг
                        local prompt = obj:FindFirstChildOfClass("ProximityPrompt")
                        if prompt then
                            proximityPrompt = prompt
                            closestDrop = obj
                            closestDistance = distance
                        else
                            -- Проверяем в родительской модели
                            local model = obj:FindFirstAncestorOfClass("Model")
                            if model then
                                prompt = model:FindFirstChildWhichIsA("ProximityPrompt", true)
                                if prompt then
                                    proximityPrompt = prompt
                                    closestDrop = obj
                                    closestDistance = distance
                                end
                            end
                        end
                    end
                end
            end
        end
        
        if closestDrop then
            -- Телепортируемся к боксу
            local targetPos = closestDrop.Position + Vector3.new(0, 2, 0)
            smoothTeleport(targetPos)
            
            -- Ждем немного для загрузки
            task.wait(0.5)
            
            -- Пытаемся подобрать бокс
            local pickupSuccess = false
            
            -- Если нашли ProximityPrompt, активируем его
            if proximityPrompt then
                pickupSuccess = pcall(function()
                    fireproximityprompt(proximityPrompt)
                end)
                
                -- Ждем немного для анимации поднятия
                task.wait(0.7)
            else
                -- Пробуем найти ProximityPrompt рядом с боксом
                for _, obj in pairs(Workspace:GetDescendants()) do
                    if obj:IsA("ProximityPrompt") and (obj.Parent == closestDrop or 
                       (obj.Parent:IsA("BasePart") and (obj.Parent.Position - closestDrop.Position).Magnitude < 5)) then
                        pcall(function()
                            fireproximityprompt(obj)
                            pickupSuccess = true
                        end)
                        break
                    end
                end
                
                -- Если не нашли ProximityPrompt, попробуем нажать E
                if not pickupSuccess then
                    -- Симулируем нажатие клавиши E
                    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                    task.wait(0.3)
                    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                    
                    -- Ждем немного для анимации поднятия
                    task.wait(0.7)
                end
            end
            
            -- Возвращаемся на исходную позицию
            smoothTeleport(originalPosition)
            
            -- Восстанавливаем ориентацию
            if hrp and hrp.Parent then
                hrp.CFrame = CFrame.new(hrp.Position) * (originalCFrame - originalCFrame.Position)
            end
        end
    end
})

FarmTab:CreateSection("Auto Farm")

local runningAutoFarm = false
local autoFarmEnabled = false 

FarmTab:CreateToggle({
    Name = "Auto Farm KB",
    CurrentValue = false,
    Flag = "AutoFarmKB", 
    Callback = function(Value)
        runningAutoFarm = Value
        autoFarmEnabled = Value 

        local player = Players.LocalPlayer
        local playerTeam = player.Team
        local requiredTeam = game:GetService("Teams"):FindFirstChild("КОНТРАБАНДИСТЫ")

        if not requiredTeam or playerTeam ~= requiredTeam then
            -- Убираю уведомление о неправильной команде, но сохраняю логику остановки
            runningAutoFarm = false
            autoFarmEnabled = false
            return
        end

        if Value then
            task.spawn(function()
                while runningAutoFarm and autoFarmEnabled do 
                    local character = player.Character
                    if not character or not character:FindFirstChild("HumanoidRootPart") then
                        task.wait(1)
                        continue
                    end

                    local function interactWithPrompt(prompt, holdDuration)
                        if prompt then
                            if prompt:IsA("ProximityPrompt") then
                                -- Adding random delay to simulate human behavior
                                task.wait(math.random(3, 7) / 10)
                                
                                if holdDuration then
                                    -- Hold button for long interaction
                                    prompt.HoldDuration = holdDuration
                                    fireproximityprompt(prompt, 0)  -- Start holding
                                    task.wait(holdDuration + math.random(1, 3) / 10)
                                    fireproximityprompt(prompt, 1)  -- End holding
                                else
                                    -- Regular press
                                    fireproximityprompt(prompt)
                                end
                                
                                -- Wait a bit more after interaction
                                task.wait(math.random(2, 5) / 10)
                                return true
                            elseif prompt:IsA("ClickDetector") then
                                task.wait(math.random(2, 5) / 10)
                                fireclickdetector(prompt)
                                task.wait(math.random(2, 5) / 10)
                                return true
                            end
                        end
                        return false
                    end

                    local function smoothFlyToPosition(targetPos)
                        local player = Players.LocalPlayer
                        local character = player and player.Character
                        if not character then return end

                        local hrp = character:FindFirstChild("HumanoidRootPart")
                        if not hrp then return end

                        -- Direct teleportation instead of movement under the map
                        hrp.CFrame = CFrame.new(targetPos)
                        hrp.Velocity = Vector3.new(0, 0, 0)
                        hrp.RotVelocity = Vector3.new(0, 0, 0)

                        -- Small pause for stability
                        task.wait(0.1)
                    end

                    local function findNPCAtPosition()
                        -- Updated coordinates based on new data
                        local npcTargetPos = Vector3.new(616.835449, 3.11895752, -681.120483)
                        local buttonTargetPos = Vector3.new(621.910645, 4.00023508, -700.328125)
                        local maxDistance = 15 -- Significantly increasing search radius
                        
                        -- Direct search for ProximityPrompt in workspace
                        for _, prompt in pairs(Workspace:GetDescendants()) do
                            if prompt:IsA("ProximityPrompt") then
                                local parent = prompt.Parent
                                if parent and parent:IsA("BasePart") then
                                    local distance = (parent.Position - npcTargetPos).Magnitude
                                    if distance <= maxDistance then
                                        local model = parent:FindFirstAncestorWhichIsA("Model")
                                        if model then
                                            return model, prompt
                                        else
                                            return parent, prompt
                                        end
                                    end
                                end
                            end
                        end
                        
                        -- Backup method: search through BaseParts
                        local partsInRadius = {}
                        for _, obj in pairs(Workspace:GetDescendants()) do
                            if obj:IsA("BasePart") then
                                local distance = (obj.Position - npcTargetPos).Magnitude
                                if distance <= maxDistance then
                                    table.insert(partsInRadius, obj)
                                end
                            end
                        end

                        for _, part in pairs(partsInRadius) do
                            -- Check part itself for ProximityPrompt
                            local prompt = part:FindFirstChildOfClass("ProximityPrompt")
                            if prompt then
                                local model = part:FindFirstAncestorWhichIsA("Model")
                                return model or part, prompt
                            end
                            
                            -- Check model if part is part of a model
                            local model = part:FindFirstAncestorWhichIsA("Model")
                            if model then
                                -- Search for all possible interactive elements
                                local interactives = {}
                                
                                for _, descendant in pairs(model:GetDescendants()) do
                                    if descendant:IsA("ProximityPrompt") or descendant:IsA("ClickDetector") then
                                        table.insert(interactives, descendant)
                                    end
                                end
                                
                                if #interactives > 0 then
                                    return model, interactives[1] -- Return the first found interactive element
                                end
                            end
                        end
                        
                        return nil, nil
                    end

                    local function safeInteractWithNPC()
                        -- Создаем CFrame для точной телепортации к NPC
                        local npcCFrame = CFrame.new(615.063904, 4.01849461, -683.681519, -0.734342337, 2.26861339e-08, -0.678779304, -5.13088771e-08, 1, 8.89308396e-08, 0.678779304, 1.00133086e-07, -0.734342337)
                        
                        -- Телепортируемся к NPC
                        local character = Players.LocalPlayer.Character
                        if not character or not character:FindFirstChild("HumanoidRootPart") then
                            return false
                        end
                        
                        -- Телепортируемся на точные координаты без уведомления
                        smoothFlyToPosition(npcCFrame.Position)
                        
                        -- Небольшая задержка перед поиском промптов
                        task.wait(0.5)
                        
                        -- Функция для получения ближайшего промпта
                        local function getClosestPrompt()
                            local character = Players.LocalPlayer.Character
                            if not character or not character:FindFirstChild("HumanoidRootPart") then
                                return nil
                            end
                        
                            local hrpPos = character.HumanoidRootPart.Position
                            local closestPrompt = nil
                            local closestDistance = math.huge
                        
                            for _, prompt in ipairs(workspace:GetDescendants()) do
                                if prompt:IsA("ProximityPrompt") and prompt.Enabled then
                                    local promptPart = prompt.Parent
                                    if promptPart and promptPart:IsA("BasePart") then
                                        local distance = (promptPart.Position - hrpPos).Magnitude
                                        if distance <= prompt.MaxActivationDistance and distance < closestDistance then
                                            closestDistance = distance
                                            closestPrompt = prompt
                                        end
                                    end
                                end
                            end
                        
                            return closestPrompt
                        end
                        
                        -- Ищем ближайший промпт после телепортации
                        local promptToActivate = getClosestPrompt()
                        
                        if promptToActivate then
                            -- Активируем промпт ровно один раз без уведомления
                            fireproximityprompt(promptToActivate)
                            
                            -- Небольшая задержка после взаимодействия
                            task.wait(0.5)
                            
                            return true
                        else
                            return false
                        end
                    end

                    local function findAndInteractWithBox()
                        local interactableFolder = Workspace:FindFirstChild("Interactable")
                        if interactableFolder then
                            -- Check several possible elements (not just 18th)
                            local possibleIndices = {18, 19, 20, 17, 16}
                            local targetItem
                            
                            for _, index in ipairs(possibleIndices) do
                                if interactableFolder:GetChildren()[index] then
                                    targetItem = interactableFolder:GetChildren()[index]
                                    if targetItem:FindFirstChild("ProximityPrompt") then
                                        break
                                    end
                                end
                            end
                            
                            if targetItem and targetItem:FindFirstChild("ProximityPrompt") then
                                -- Move to the box
                                smoothFlyToPosition(targetItem.Position)
                                
                                -- Simulate human behavior: pause before interaction
                                task.wait(math.random(8, 15) / 10)
                                
                                -- Функция имитации удержания клавиши E на заданное время (в секундах)
                                local function holdKeyE(duration)
                                    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game) -- Нажать E
                                    task.wait(duration) -- Удерживать
                                    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game) -- Отпустить E
                                end
                                
                                -- Взаимодействуем с коробкой, удерживая E без уведомления
                                holdKeyE(3.5) -- Зажимаем E на 3.5 секунды для взаимодействия
                                
                                return true
                            else
                                return false
                            end
                        else
                            return false
                        end
                    end

                    while autoFarmEnabled do 
                        if not runningAutoFarm then break end
                        
                        -- Step 1: Interact with NPC to get the task
                        if not safeInteractWithNPC() then
                            task.wait(5)
                            continue
                        end
                        
                        if not autoFarmEnabled then break end
                        
                        -- Step 2: Interact with the box
                        if not findAndInteractWithBox() then
                            task.wait(5)
                            continue
                        end
                        
                        if not autoFarmEnabled then break end
                        
                        -- Step 3: Return to NPC to complete the task
                        if not safeInteractWithNPC() then
                            task.wait(5)
                            continue
                        end
                        
                        -- Random delay between cycles
                        task.wait(math.random(20, 30) / 10)
                    end
                end
            end)
        end
    end
})

local PvpTab = Window:CreateTab("PvP", 4483345998)
local HitboxSection = PvpTab:CreateSection("Hitbox") -- Renaming section variable for clarity

-- Настройки для скрипта увеличения хитбоксов головы
local HeadHitboxSettings = {
    Enabled = false,
    OthersTransparency = 0.7, -- Fixed transparency for other players' heads
    HeadSize = 6 -- Size of other players' heads (default 6)
}

-- Функция для изменения размера и прозрачности головы игрока
-- Now accepts an additional argument for head size
local function ResizeAndTransparentizeHead(targetPlayer)
    -- Minimizing delay
    task.wait(0.02)
    local character = targetPlayer.Character
    if not character then return end

    -- IMPORTANT CHANGE: Checking if the player is local and skipping processing for local player
    if targetPlayer == game.Players.LocalPlayer then
        return -- Not processing local player at all
    end

    local head = character:FindFirstChild("Head")
    if head and head:IsA("BasePart") then
        -- Apply settings only if the function is enabled
        if HeadHitboxSettings.Enabled then
            -- Set the head size for other players (enlarged hitbox)
            pcall(function() 
                head.Size = Vector3.new(HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize) 
                head.Transparency = HeadHitboxSettings.OthersTransparency
                
                -- For stability, let's mark that we've already modified this object
                if not head:FindFirstChild("RAILhubHeadModified") then
                    local marker = Instance.new("StringValue")
                    marker.Name = "RAILhubHeadModified"
                    marker.Value = "true"
                    marker.Parent = head
                end
            end)
        else
            -- If the function is disabled, restore standard settings for other players
            pcall(function() 
                head.Size = Vector3.new(1, 1, 1) 
                head.Transparency = 0
                
                -- Remove the marker
                local marker = head:FindFirstChild("RAILhubHeadModified")
                if marker then
                    marker:Destroy()
                end
            end)
        end
    end
end

-- UI элементы для управления скриптом
-- Вызываем CreateToggle на PvpTab (вкладке), а не на HitboxSection (секции)
PvpTab:CreateToggle({ -- ИСПРАВЛЕНО: Вызываем на PvpTab
    Name = "Big Hitbox [Magnification is not always visible]",
    CurrentValue = false,
    Flag = "HeadHitboxExpanderEnabled",
    Callback = function(Value)
        HeadHitboxSettings.Enabled = Value
        -- When enabling or disabling, forcibly apply settings to all existing players
        local servicePlayer = game:GetService("Players")
        
        -- Aggressive application of changes to all players
        task.spawn(function()
            -- First wave of changes
            for _, p in ipairs(servicePlayer:GetPlayers()) do
                if p ~= game.Players.LocalPlayer then
                    task.spawn(function() -- Parallel execution for speed
                        ResizeAndTransparentizeHead(p)
                    end)
                end
            end
            
            -- Second wave after 0.5 seconds for stability
            task.wait(0.5)
            for _, p in ipairs(servicePlayer:GetPlayers()) do
                if p ~= game.Players.LocalPlayer then
                    task.spawn(function()
                        ResizeAndTransparentizeHead(p)
                    end)
                end
            end
            
            -- Third wave after 1 second for guarantee
            task.wait(0.5)
            for _, p in ipairs(servicePlayer:GetPlayers()) do
                if p ~= game.Players.LocalPlayer then
                    task.spawn(function()
                        ResizeAndTransparentizeHead(p)
                    end)
                end
            end
        end)

        -- Notify user
        Rayfield:Notify({
            Title = "Head Hitboxes",
            Content = Value and "Head hitbox enlargement enabled" or "Head hitbox enlargement disabled",
            Duration = 3,
            Image = 4483345998
        })
    end
})

-- Replace transparency slider with head size slider
PvpTab:CreateSlider({ -- FIXED: Calling on PvpTab
    Name = "Other Players' Head Size",
    Range = {3, 12},
    Increment = 0.5,
    Suffix = "",
    CurrentValue = HeadHitboxSettings.HeadSize,
    Flag = "OthersHeadSize",
    Callback = function(Value)
        HeadHitboxSettings.HeadSize = Value
        -- Apply new size to all existing players (except self)
        local servicePlayer = game:GetService("Players")
        local player = servicePlayer.LocalPlayer
        for _, p in ipairs(servicePlayer:GetPlayers()) do
            if p ~= player and p.Character then
                 task.wait(0.05)
                 local head = p.Character:FindFirstChild("Head")
                 if head and head:IsA("BasePart") then
                     pcall(function() 
                        head.Size = Vector3.new(Value, Value, Value) 
                     end)
                 end
            end
        end
        Rayfield:Notify({
            Title = "Head Size",
            Content = "Other players' head size: " .. string.format("%.1f", Value),
            Duration = 2,
            Image = 4483345998
        })
    end
})

-- Creating global connections to track CharacterAdded for all players
if _G.HeadHitboxCharacterConnections then
    -- Disconnect old connections if they exist
    for _, connection in pairs(_G.HeadHitboxCharacterConnections) do
        if connection and typeof(connection) == "RBXScriptConnection" then
            connection:Disconnect()
        end
    end
end
_G.HeadHitboxCharacterConnections = {}

-- Creating a timer for periodic checking of all heads
if _G.HeadHitboxTimer then
    task.cancel(_G.HeadHitboxTimer)
    _G.HeadHitboxTimer = nil
end

_G.HeadHitboxTimer = task.spawn(function()
    while true do
        -- Check every 0.3 seconds
        task.wait(0.3)
        
        if HeadHitboxSettings.Enabled then
            -- Check all players
            for _, p in ipairs(game:GetService("Players"):GetPlayers()) do
                if p ~= game.Players.LocalPlayer and p.Character then
                    -- Check if character has a head
                    local head = p.Character:FindFirstChild("Head")
                    if head and head:IsA("BasePart") then
                        -- Check size and transparency
                        if head.Size.X ~= HeadHitboxSettings.HeadSize or 
                           head.Size.Y ~= HeadHitboxSettings.HeadSize or 
                           head.Size.Z ~= HeadHitboxSettings.HeadSize or
                           head.Transparency ~= HeadHitboxSettings.OthersTransparency then
                            
                            -- Apply settings
                            pcall(function()
                                head.Size = Vector3.new(HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize)
                                head.Transparency = HeadHitboxSettings.OthersTransparency
                                
                                -- Add marker
                                if not head:FindFirstChild("RAILhubHeadModified") then
                                    local marker = Instance.new("StringValue")
                                    marker.Name = "RAILhubHeadModified"
                                    marker.Value = "true"
                                    marker.Parent = head
                                end
                            end)
                        end
                    end
                end
            end
        end
    end
end)

-- Processing CharacterAdded for all players
for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
    if player ~= game.Players.LocalPlayer then
        local connection = player.CharacterAdded:Connect(function(character)
            -- Process new character
            task.wait(0.1) -- Small delay for loading
            
            if HeadHitboxSettings.Enabled then
                -- Apply settings directly
                local head = character:FindFirstChild("Head")
                if head and head:IsA("BasePart") then
                    pcall(function()
                        head.Size = Vector3.new(HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize)
                        head.Transparency = HeadHitboxSettings.OthersTransparency
                        
                        -- Add marker
                        if not head:FindFirstChild("RAILhubHeadModified") then
                            local marker = Instance.new("StringValue")
                            marker.Name = "RAILhubHeadModified"
                            marker.Value = "true"
                            marker.Parent = head
                        end
                    end)
                end
                
                -- If there's no head, add ChildAdded handler
                if not character:FindFirstChild("Head") then
                    character.ChildAdded:Connect(function(child)
                        if child.Name == "Head" and child:IsA("BasePart") and HeadHitboxSettings.Enabled then
                            task.wait(0.05) -- Small delay for loading
                            
                            pcall(function()
                                child.Size = Vector3.new(HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize)
                                child.Transparency = HeadHitboxSettings.OthersTransparency
                                
                                -- Add marker
                                if not child:FindFirstChild("RAILhubHeadModified") then
                                    local marker = Instance.new("StringValue")
                                    marker.Name = "RAILhubHeadModified"
                                    marker.Value = "true"
                                    marker.Parent = child
                                end
                            end)
                        end
                    end)
                end
            end
        end)
        
        table.insert(_G.HeadHitboxCharacterConnections, connection)
    end
end

-- Processing new players when they are added
game:GetService("Players").PlayerAdded:Connect(function(newPlayer)
    -- Check that this is not a local player
    if newPlayer == game.Players.LocalPlayer then return end
    
    -- Add CharacterAdded handler
    local connection = newPlayer.CharacterAdded:Connect(function(character)
        -- Wait a small delay for loading
        task.wait(0.1)
        
        if HeadHitboxSettings.Enabled then
            -- Check if there is a head
            local head = character:FindFirstChild("Head")
            if head and head:IsA("BasePart") then
                -- Apply settings directly
                pcall(function()
                    head.Size = Vector3.new(HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize)
                    head.Transparency = HeadHitboxSettings.OthersTransparency
                    
                    -- Add marker
                    if not head:FindFirstChild("RAILhubHeadModified") then
                        local marker = Instance.new("StringValue")
                        marker.Name = "RAILhubHeadModified"
                        marker.Value = "true"
                        marker.Parent = head
                    end
                    
                    -- Add change tracking
                    head:GetPropertyChangedSignal("Size"):Connect(function()
                        if HeadHitboxSettings.Enabled then
                            local expectedSize = Vector3.new(HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize)
                            if head.Size ~= expectedSize then
                                task.spawn(function()
                                    pcall(function()
                                        head.Size = expectedSize
                                    end)
                                end)
                            end
                        end
                    end)
                    
                    head:GetPropertyChangedSignal("Transparency"):Connect(function()
                        if HeadHitboxSettings.Enabled then
                            if head.Transparency ~= HeadHitboxSettings.OthersTransparency then
                                task.spawn(function()
                                    pcall(function()
                                        head.Transparency = HeadHitboxSettings.OthersTransparency
                                    end)
                                end)
                            end
                        end
                    end)
                end)
            end
            
            -- If there's no head, add ChildAdded handler
            if not character:FindFirstChild("Head") then
                character.ChildAdded:Connect(function(child)
                    if child.Name == "Head" and HeadHitboxSettings.Enabled then
                        task.wait(0.05) -- Delay for loading
                        
                        pcall(function()
                            child.Size = Vector3.new(HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize)
                            child.Transparency = HeadHitboxSettings.OthersTransparency
                            
                            -- Add marker
                            if not child:FindFirstChild("RAILhubHeadModified") then
                                local marker = Instance.new("StringValue")
                                marker.Name = "RAILhubHeadModified"
                                marker.Value = "true"
                                marker.Parent = child
                            end
                            
                            -- Add change tracking
                            child:GetPropertyChangedSignal("Size"):Connect(function()
                                if HeadHitboxSettings.Enabled then
                                    local expectedSize = Vector3.new(HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize)
                                    if child.Size ~= expectedSize then
                                        task.spawn(function()
                                            pcall(function()
                                                child.Size = expectedSize
                                            end)
                                        end)
                                    end
                                end
                            end)
                            
                            child:GetPropertyChangedSignal("Transparency"):Connect(function()
                                if HeadHitboxSettings.Enabled then
                                    if child.Transparency ~= HeadHitboxSettings.OthersTransparency then
                                        task.spawn(function()
                                            pcall(function()
                                                child.Transparency = HeadHitboxSettings.OthersTransparency
                                            end)
                                        end)
                                    end
                                end
                            end)
                        end)
                    end
                end)
            end
        end
    end)
    
    table.insert(_G.HeadHitboxCharacterConnections, connection)
    
    -- If the player already has a character, process it
    if newPlayer.Character then
        if HeadHitboxSettings.Enabled then
            -- Apply immediately
            task.spawn(function()
                ResizeAndTransparentizeHead(newPlayer)
            end)
            
            -- And once more after a small delay for guarantee
            task.delay(0.2, function()
                if HeadHitboxSettings.Enabled then
                    ResizeAndTransparentizeHead(newPlayer)
                end
            end)
        end
    end
end)

local AimbotSection = PvpTab:CreateSection("Aimbot")

-- Настройки аимбота
local Aimbot = {
    Enabled = false,
    TeamCheck = true,
    ShowFOV = false,
    VisibilityCheck = true,
    FOVSize = 100,
    Smoothness = 0.5,
    PredictionAmount = 0.15,
    TargetPart = "Head",
    FOVColor = Color3.fromRGB(255, 255, 255),
    FOVTransparency = 1,
    HeadOffset = Vector3.new(0, 0, 0), -- Без смещения по вертикали, чтобы целиться точно в голову
    Keybind = nil,
    MouseButton = Enum.UserInputType.MouseButton2 -- M2 (правая кнопка мыши) по умолчанию
}

-- Создаем круг FOV для визуализации
local AimbotFOVCircle = Drawing.new("Circle")
AimbotFOVCircle.Thickness = 2
AimbotFOVCircle.NumSides = 36
AimbotFOVCircle.Radius = Aimbot.FOVSize
AimbotFOVCircle.Filled = false
AimbotFOVCircle.Visible = false
AimbotFOVCircle.Transparency = Aimbot.FOVTransparency
AimbotFOVCircle.Color = Aimbot.FOVColor

-- Обновление круга FOV
RunService.RenderStepped:Connect(function()
    if AimbotFOVCircle and Aimbot.ShowFOV then
        AimbotFOVCircle.Position = UserInputService:GetMouseLocation()
        AimbotFOVCircle.Radius = Aimbot.FOVSize
        AimbotFOVCircle.Transparency = Aimbot.FOVTransparency
        AimbotFOVCircle.Color = Aimbot.FOVColor
        AimbotFOVCircle.Visible = Aimbot.ShowFOV
    else
        if AimbotFOVCircle then
            AimbotFOVCircle.Visible = false
        end
    end
end)

-- Переменные для аимбота
local target = nil
local aiming = false
local camera = Workspace.CurrentCamera

-- Функция для проверки видимости
local function IsVisible(part, partDescendant)
    local character = Players.LocalPlayer.Character
    local origin = camera.CFrame.Position
    local direction = (part.Position - origin).Unit * 300
    local ray = Ray.new(origin, direction)
    local hit, position = Workspace:FindPartOnRayWithIgnoreList(ray, {character, camera})
    if hit and hit:IsDescendantOf(partDescendant) then
        return true
    end
    return false
end

-- Функция для получения ближайшего игрока к мыши
local function GetClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge
    
    local mousePos = UserInputService:GetMouseLocation()
    local localPlayer = Players.LocalPlayer
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            -- Проверка команды
            if Aimbot.TeamCheck and player.Team == localPlayer.Team then continue end
            
            local character = player.Character
            if character and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0 then
                local targetPart = character:FindFirstChild(Aimbot.TargetPart)
                
                if targetPart then
                    -- Проверка видимости
                    if Aimbot.VisibilityCheck then
                        if not IsVisible(targetPart, character) then continue end
                    end
                    
                    local pos, onScreen = camera:WorldToScreenPoint(targetPart.Position)
                    if onScreen then
                        local distance = (Vector2.new(mousePos.X, mousePos.Y) - Vector2.new(pos.X, pos.Y)).Magnitude
                        -- Проверка, находится ли игрок в пределах FOV
                        if distance > Aimbot.FOVSize then continue end
                        
                        if distance < shortestDistance then
                            closestPlayer = player
                            shortestDistance = distance
                        end
                    end
                end
            end
        end
    end
    
    return closestPlayer
end

-- Функция для направления камеры на игрока с предсказанием
local function AimAtTarget(target)
    if not (target and target.Character) then return end
    
    local targetPart = target.Character:FindFirstChild(Aimbot.TargetPart)
    if not targetPart then return end
    
    local targetPos = targetPart.Position
    
    -- Добавляем предсказание, если игрок движется
    local velocity = targetPart.Velocity
    targetPos = targetPos + (velocity * Aimbot.PredictionAmount)
    
    -- Расчет направления камеры с учетом смещения для точного наведения на голову
    local aimPos = targetPos + Aimbot.HeadOffset
    
    -- Плавное наведение с помощью интерполяции
    local smoothness = 1 - Aimbot.Smoothness
    camera.CFrame = camera.CFrame:Lerp(CFrame.new(camera.CFrame.Position, aimPos), smoothness)
end

-- Aimbot loop
local aimLoop = nil

local function StartAimbot()
    if aimLoop then return end
    
    target = GetClosestPlayer()
    aiming = true
    
    aimLoop = RunService.RenderStepped:Connect(function()
        if not Aimbot.Enabled or not aiming then return end
        
        -- Постоянно обновляем цель для динамической смены
        target = GetClosestPlayer()
        
        if target then
            local targetPart = target.Character and target.Character:FindFirstChild(Aimbot.TargetPart)
            if targetPart then
                AimAtTarget(target)
            end
        end
    end)
end

local function StopAimbot()
    aiming = false
    if aimLoop then
        aimLoop:Disconnect()
        aimLoop = nil
    end
end

-- Обработчики ввода для активации/деактивации аимбота
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed then
        if Aimbot.MouseButton then
            -- Проверка кнопки мыши
            if input.UserInputType == Aimbot.MouseButton then
                aiming = true
                StartAimbot()
            end
        elseif input.KeyCode == Aimbot.Keybind then
            aiming = true
            StartAimbot()
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if not gameProcessed then
        if Aimbot.MouseButton then
            -- Проверка кнопки мыши
            if input.UserInputType == Aimbot.MouseButton then
                aiming = false
                StopAimbot()
            end
        elseif input.KeyCode == Aimbot.Keybind then
            aiming = false
            StopAimbot()
        end
    end
end)

-- UI для настроек аимбота
PvpTab:CreateToggle({
    Name = "Enable Aimbot",
    CurrentValue = false,
    Flag = "AimbotEnabled",
    Callback = function(Value)
        Aimbot.Enabled = Value
        if not Value then
            StopAimbot()
        end
    end
})

PvpTab:CreateToggle({
    Name = "Team Check",
    CurrentValue = true,
    Flag = "AimbotTeamCheck",
    Callback = function(Value)
        Aimbot.TeamCheck = Value
    end
})

PvpTab:CreateToggle({
    Name = "Show FOV",
    CurrentValue = false,
    Flag = "AimbotShowFOV",
    Callback = function(Value)
        Aimbot.ShowFOV = Value
    end
})

PvpTab:CreateToggle({
    Name = "Visibility Check",
    CurrentValue = true,
    Flag = "AimbotVisibilityCheck",
    Callback = function(Value)
        Aimbot.VisibilityCheck = Value
    end
})

PvpTab:CreateSlider({
    Name = "FOV Size",
    Range = {5, 800},
    Increment = 5,
    Suffix = "px",
    CurrentValue = 100,
    Flag = "AimbotFOVSize",
    Callback = function(Value)
        Aimbot.FOVSize = Value
    end
})

PvpTab:CreateSlider({
    Name = "Smoothness",
    Range = {0, 1},
    Increment = 0.01,
    Suffix = "",
    CurrentValue = 0.5,
    Flag = "AimbotSmoothness",
    Callback = function(Value)
        Aimbot.Smoothness = Value
    end
})

PvpTab:CreateSlider({
    Name = "Prediction",
    Range = {0, 1},
    Increment = 0.01,
    Suffix = "",
    CurrentValue = 0.15,
    Flag = "AimbotPrediction",
    Callback = function(Value)
        Aimbot.PredictionAmount = Value
    end
})

PvpTab:CreateDropdown({
    Name = "Target Part",
    Options = {"Head", "HumanoidRootPart", "Torso",},
    CurrentOption = "Head",
    Flag = "AimbotTargetPart",
    Callback = function(Value)
        Aimbot.TargetPart = Value
    end
})

-- Добавляю выпадающее меню для выбора кнопки наведения
PvpTab:CreateDropdown({
    Name = "Aimbot Button",
    Options = {"M1", "M2", "E", "X"},
    CurrentOption = "M2",
    Flag = "AimbotButton",
    Callback = function(Value)
        -- Сбрасываем предыдущие настройки
        Aimbot.Keybind = nil
        Aimbot.MouseButton = nil
        
        -- Устанавливаем новую кнопку в зависимости от выбора
        if Value == "E" then
            Aimbot.Keybind = Enum.KeyCode.E
        elseif Value == "X" then
            Aimbot.Keybind = Enum.KeyCode.X
        elseif Value == "M1" then
            Aimbot.MouseButton = Enum.UserInputType.MouseButton1
        elseif Value == "M2" then
            Aimbot.MouseButton = Enum.UserInputType.MouseButton2
        end
        
        -- Уведомление о смене кнопки
        Rayfield:Notify({
            Title = "Aimbot Button",
            Content = "New button: " .. Value,
            Duration = 2,
            Image = 4483345998
        })
    end
})

local ESPTab = Window:CreateTab("ESP", 7733774602)
local ESP = {
    Enabled     = false,
    Boxes       = false,
    BoxShift    = CFrame.new(0, -1.5, 0),
    BoxSize     = Vector3.new(4, 6, 0),
    Color       = Color3.fromRGB(255, 255, 255),
    HealthBars  = false,
    Names       = false,
    Distance    = false,
    Chams       = false,
    Skeletons   = false,
    Weapon      = false,
    LookAt      = false,
    TracerFrom  = "Bottom", -- Bottom, Top, Mouse
    Tracers     = false,
    Transparency = 1,
    TeamDisplay = false,
    Font        = Drawing.Fonts.System,
    TextOutline = true,
    MaxDistance = 10000000,
    TeamCheck   = false,
    Players     = true,
    TeamColor   = false,
    ShowTeammates = true,
    RainbowColor = false,
    Rainbow = {
        Speed = 1,
        Phase = 0
    }
}
if not _G.RAILhubConnections then _G.RAILhubConnections = {} end
if not _G.RAILhubDrawings then _G.RAILhubDrawings = {} end
if not _G.RAILhubHighlights then _G.RAILhubHighlights = {} end

local function CreateDrawing(type, properties)
    local drawing = Drawing.new(type)
    for property, value in pairs(properties) do
        drawing[property] = value
    end
    table.insert(_G.RAILhubDrawings, drawing)
    return drawing
end

local function GetRelativePosition(position)
    if not position then return Vector2.new(0, 0), false, 0 end
    
    local localPlayer = Players.LocalPlayer
    local character = localPlayer and localPlayer.Character
    local localRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    local success, result = pcall(function()
        local screenPos, onScreen = Workspace.CurrentCamera:WorldToViewportPoint(position)
        local dist = localRootPart and (localRootPart.Position - position).Magnitude or screenPos.Z
        return {screenPos, onScreen, dist} -- Возвращаем таблицу для упрощения проверки
    end)
    
    if success and type(result) == "table" and #result == 3 then
        local screenPos = result[1]
        local onScreen = result[2]
        local dist = result[3]

        -- Исправляем проверку типа для screenPos
        if type(screenPos) == "vector" and type(onScreen) == "boolean" and type(dist) == "number" then
            return Vector2.new(screenPos.X, screenPos.Y), onScreen, dist
        else
            -- Если типы неверны, логируем и возвращаем значения по умолчанию
            print("[DEBUG] GetRelativePosition: Type mismatch in pcall result. screenPos:", type(screenPos), "onScreen:", type(onScreen), "dist:", type(dist))
            return Vector2.new(0, 0), false, 0
        end
    else
        -- Если pcall не удался или вернул не то, что ожидалось
        print("[DEBUG] GetRelativePosition: pcall failed or returned unexpected result. Success:", success, "Result:", result)
        return Vector2.new(0, 0), false, 0
    end
end

local function GetEquippedWeapon(character)
    local weapon = "Hands"
    if character then
        for _, obj in pairs(character:GetChildren()) do
            if obj:IsA("Tool") and obj:FindFirstChild("Handle") then
                weapon = obj.Name
                break
            end
        end
    end
    return weapon
end

local function IsLookingAtPlayer(watcher, target)
    local watchers = watcher:FindFirstChild("Head")
    local targets = target:FindFirstChild("Head")
    
    if not watchers or not targets then return false end
    
    local direction = (targets.Position - watchers.Position).Unit
    local lookVector = watchers.CFrame.LookVector
    
    local dot = direction:Dot(lookVector)
    -- Considered that player is looking at you if angle between their look direction and direction to you is less than 0.2 radians
    return dot > 0.9
end

local function GetColorBasedOnTeam(player)
    if not ESP.TeamColor then return ESP.Color end
    
    if player.Team == nil then return ESP.Color end
    
    -- Recreate to use team color
    return player.Team.TeamColor.Color
end

local function UpdateRainbowColor(phase)
    local frequency = 2 * math.pi / 360
    local r = math.sin(frequency * phase + 0) * 127 + 128
    local g = math.sin(frequency * phase + 2 * math.pi / 3) * 127 + 128
    local b = math.sin(frequency * phase + 4 * math.pi / 3) * 127 + 128
    return Color3.fromRGB(r, g, b)
end

local ESPObject = {}
ESPObject.__index = ESPObject

function ESPObject.new(player)
    local self = setmetatable({}, ESPObject)
    self.Player = player
    
    self.Box = {
        Outline = CreateDrawing("Square", {Thickness = 3, Color = Color3.new(0, 0, 0), Transparency = 1, Filled = false, Visible = false}),
        Main    = CreateDrawing("Square", {Thickness = 1, Color = ESP.Color, Transparency = 1, Filled = false, Visible = false})
    }
    self.Healthbar = {
        Outline = CreateDrawing("Square", {Thickness = 3, Color = Color3.new(0, 0, 0), Transparency = 1, Filled = false, Visible = false}),
        Main    = CreateDrawing("Square", {Thickness = 1, Color = Color3.fromRGB(0, 255, 0), Transparency = 1, Filled = true, Visible = false})
    }
    self.Name     = CreateDrawing("Text", {Text = player.Name, Size = 13, Center = true, Outline = ESP.TextOutline, Color = ESP.Color, Visible = false, Font = Drawing.Fonts.System})
    self.Team     = CreateDrawing("Text", {Text = "", Size = 12, Center = true, Outline = ESP.TextOutline, Color = ESP.Color, Visible = false, Font = Drawing.Fonts.System})
    self.Distance = CreateDrawing("Text", {Size = 13, Center = true, Outline = ESP.TextOutline, Color = ESP.Color, Visible = false, Font = Drawing.Fonts.System})
    self.Weapon   = CreateDrawing("Text", {Size = 13, Center = true, Outline = ESP.TextOutline, Color = ESP.Color, Visible = false, Font = Drawing.Fonts.System})
    self.LookingAt = CreateDrawing("Text", {Text = "👁️", Size = 14, Center = true, Outline = false, Color = Color3.fromRGB(255, 0, 0), Visible = false, Font = Drawing.Fonts.System})
    self.Tracer   = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false})
    
    -- Skeleton для R15 и R6
    self.Skeleton = {
        Head_Torso = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        -- R15 соединения
        UpperTorso_LowerTorso = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        LowerTorso_LeftUpperLeg = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        LowerTorso_RightUpperLeg = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        UpperTorso_LeftUpperArm = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        UpperTorso_RightUpperArm = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        LeftUpperArm_LeftLowerArm = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        RightUpperArm_RightLowerArm = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        LeftLowerArm_LeftHand = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        RightLowerArm_RightHand = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        LeftUpperLeg_LeftLowerLeg = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        RightUpperLeg_RightLowerLeg = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        LeftLowerLeg_LeftFoot = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        RightLowerLeg_RightFoot = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        -- R6 соединения
        Torso_LeftArm = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        Torso_RightArm = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        Torso_LeftLeg = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        Torso_RightLeg = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false})
    }
    
    -- Create Highlight for Chams
    self.Chams = nil
    self:CreateChams()
    
    return self
end

function ESPObject:CreateChams()
    -- Remove existing chams if it exists
    if self.Chams then
        self.Chams:Destroy()
        self.Chams = nil
    end

    -- Create new Highlight instance
    self.Chams = Instance.new("Highlight")
    self.Chams.FillColor = ESP.Color
    self.Chams.OutlineColor = ESP.Color
    self.Chams.FillTransparency = 0.5
    self.Chams.OutlineTransparency = 0
    self.Chams.Enabled = false
    self.Chams.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    
    -- Set parent to CoreGui
    local success, err = pcall(function()
        self.Chams.Parent = game.CoreGui
    end)
    
    if not success then
        -- Try alternative parent if CoreGui fails
        self.Chams.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
    end
    
    -- Add to global table for cleaning up later
    table.insert(_G.RAILhubHighlights, self.Chams)
    
    -- Immediately set Adornee if player's character exists
    if self.Player and self.Player.Character then
        self:UpdateChamsAdornee(self.Player.Character)
    end
    
    -- Connect to CharacterAdded event to update chams when character respawns
    if self.CharacterAddedConnection then
        self.CharacterAddedConnection:Disconnect()
        self.CharacterAddedConnection = nil
    end
    
    self.CharacterAddedConnection = self.Player.CharacterAdded:Connect(function(char)
        task.wait(0.5) -- Даем персонажу время загрузиться
        self:UpdateChamsAdornee(char)
    end)
end

function ESPObject:UpdateChamsAdornee(character)
    if not self.Chams then 
        self:CreateChams()
        if not self.Chams then return end
    end
    
    pcall(function()
        self.Chams.Adornee = character
        
        -- If ESP.Chams is enabled, immediately enable highlight
        if ESP.Enabled and ESP.Chams then
            self.Chams.Enabled = true
        end
    end)
end

function ESPObject:Update()
    if not ESP.Enabled then return self:Hide() end
    local character = self.Player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") or not character:FindFirstChild("Humanoid") then
        return self:Hide()
    end
    
    -- Team Check
    if ESP.TeamCheck then
        local localPlayer = Players.LocalPlayer
        if localPlayer.Team and self.Player.Team == localPlayer.Team and not ESP.ShowTeammates then
            return self:Hide()
        end
    end
    
    -- Создаем Chams если они не существуют
    if not self.Chams then
        self:CreateChams()
    end
    
    -- Обновляем Adornee для Chams
    if self.Chams and self.Chams.Adornee ~= character then
        self:UpdateChamsAdornee(character)
    end
    
    local humanoid = character.Humanoid
    local rootPart = character.HumanoidRootPart
    local head = character:FindFirstChild("Head")
    -- Удаляем поиск LowerTorso, так как он не нужен для старого расчета бокса
    -- local lowerTorso = character:FindFirstChild("LowerTorso")
    if not head then return self:Hide() end -- Проверяем только Head

    local rootPos = rootPart.Position
    -- Используем GetRelativePosition для получения экранных координат и расстояния
    local headPos, onScreen, distance = GetRelativePosition(rootPos)


    if not onScreen or distance > ESP.MaxDistance then return self:Hide() end
    
    -- Динамический расчет размеров бокса (Восстанавливаем старый метод перебора вершин)
    local minX, minY = math.huge, math.huge
    local maxX, maxY = -math.huge, -math.huge
    local camera = Workspace.CurrentCamera
    
    -- Собираем все части тела персонажа (основные части для бокса)
    local bodyParts = {
        character:FindFirstChild("Head"),
        character:FindFirstChild("HumanoidRootPart"),
        character:FindFirstChild("UpperTorso"), -- R15
        character:FindFirstChild("LowerTorso"), -- R15
        character:FindFirstChild("Torso"), -- R6
        character:FindFirstChild("LeftUpperArm"), -- R15
        character:FindFirstChild("RightUpperArm"), -- R15
        character:FindFirstChild("LeftLowerArm"), -- R15
        character:FindFirstChild("RightLowerArm"), -- R15
        character:FindFirstChild("LeftHand"), -- R15
        character:FindFirstChild("RightHand"), -- R15
        character:FindFirstChild("LeftUpperLeg"), -- R15
        character:FindFirstChild("RightUpperLeg"), -- R15
        character:FindFirstChild("LeftLowerLeg"), -- R15
        character:FindFirstChild("RightLowerLeg"), -- R15
        character:FindFirstChild("LeftFoot"), -- R15
        character:FindFirstChild("RightFoot"), -- R15
        character:FindFirstChild("Left Arm"), -- R6
        character:FindFirstChild("Right Arm"), -- R6
        character:FindFirstChild("Left Leg"), -- R6
        character:FindFirstChild("Right Leg") -- R6
    }
    
    -- Находим крайние точки для всех частей тела
    local foundPoints = false
    for _, part in pairs(bodyParts) do
        if part and part:IsA("BasePart") then
             -- Пропускаем прозрачные части, чтобы не влияли на габариты видимого бокса
            if part.Transparency >= 0.9 then continue end

        -- Преобразуем 8 вершин параллелепипеда в экранные координаты
        local size = part.Size
        local cf = part.CFrame
        local corners = {
            cf * CFrame.new(-size.X/2, -size.Y/2, -size.Z/2),
            cf * CFrame.new(-size.X/2, -size.Y/2, size.Z/2),
            cf * CFrame.new(-size.X/2, size.Y/2, -size.Z/2),
            cf * CFrame.new(-size.X/2, size.Y/2, size.Z/2),
            cf * CFrame.new(size.X/2, -size.Y/2, -size.Z/2),
            cf * CFrame.new(size.X/2, -size.Y/2, size.Z/2),
            cf * CFrame.new(size.X/2, size.Y/2, -size.Z/2),
            cf * CFrame.new(size.X/2, size.Y/2, size.Z/2)
        }
        
        for _, cornerCF in pairs(corners) do
                local screenVec, onScreen = camera:WorldToViewportPoint(cornerCF.Position)
                 -- Используем screenVec.X, screenVec.Y для 2D координат
            if onScreen then
                    minX = math.min(minX, screenVec.X)
                    minY = math.min(minY, screenVec.Y)
                    maxX = math.max(maxX, screenVec.X)
                    maxY = math.max(maxY, screenVec.Y)
                    foundPoints = true
                end
            end
        end
    end
    
    -- Если не удалось найти ни одной точки на экране, скрываем ESP
    if not foundPoints or minX == math.huge or minY == math.huge or maxX == -math.huge or maxY == -math.huge then
        return self:Hide()
    end

    -- Добавляем небольшой отступ с масштабированием по расстоянию
    -- Увеличиваем базовый отступ и делаем его более зависимым от расстояния
    local basePadding = 15 -- Увеличенный базовый отступ
    local distanceScale = math.clamp(100 / math.max(1, distance), 0.5, 2) -- Масштаб зависит от расстояния
    local padding = basePadding * distanceScale -- Применяем масштаб к отступу

    minX = minX - padding
    minY = minY - padding
    maxX = maxX + padding
    maxY = maxY + padding
    
    -- Создаем бокс с вычисленными размерами
    local boxSize = Vector2.new(maxX - minX, maxY - minY)
    local boxPosition = Vector2.new(minX, minY)
    
    -- Если размеры слишком маленькие, устанавливаем минимальный размер (можно настроить)
     if boxSize.X < 15 then boxSize = Vector2.new(15, boxSize.Y) end
     if boxSize.Y < 15 then boxSize = Vector2.new(boxSize.X, 15) end

    
    -- Update color for ESP
    local espColor = ESP.Color
    
    if ESP.RainbowColor then
        espColor = UpdateRainbowColor(ESP.Rainbow.Phase)
        ESP.Rainbow.Phase = (ESP.Rainbow.Phase + ESP.Rainbow.Speed) % 360
    elseif ESP.TeamColor then
        espColor = GetColorBasedOnTeam(self.Player)
    end
    
    -- Apply transparency
    local transparency = ESP.Transparency

    if ESP.Boxes then
        self.Box.Outline.Size = boxSize
        self.Box.Outline.Position = boxPosition
        self.Box.Outline.Visible = true
        self.Box.Outline.Transparency = transparency
        
        self.Box.Main.Size = boxSize
        self.Box.Main.Position = boxPosition
        self.Box.Main.Color = espColor
        self.Box.Main.Visible = true
        self.Box.Main.Transparency = transparency
    else
        self.Box.Outline.Visible = false
        self.Box.Main.Visible = false
    end

    if ESP.Names then
        self.Name.Text = self.Player.Name
        -- Позиция имени над боксом
        self.Name.Position = Vector2.new(boxPosition.X + boxSize.X / 2, boxPosition.Y - 15)
        self.Name.Color = espColor
        self.Name.Visible = true
        self.Name.Transparency = transparency
    else
        self.Name.Visible = false
    end

    if ESP.Distance then
        self.Distance.Text = string.format("%d M", math.floor(distance))
        -- Позиция дистанции под боксом
        self.Distance.Position = Vector2.new(boxPosition.X + boxSize.X / 2, boxPosition.Y + boxSize.Y + 5)
        self.Distance.Color = espColor
        self.Distance.Visible = true
        self.Distance.Transparency = transparency
    else
        self.Distance.Visible = false
    end
    
    if ESP.Weapon then
        local weapon = GetEquippedWeapon(character)
        self.Weapon.Text = weapon
        -- Позиция оружия зависит от того, отображается ли дистанция
        local weaponPosY = boxPosition.Y + boxSize.Y + (ESP.Distance and 20 or 5)
        self.Weapon.Position = Vector2.new(boxPosition.X + boxSize.X / 2, weaponPosY)
        self.Weapon.Color = espColor
        self.Weapon.Visible = true
        self.Weapon.Transparency = transparency
    else
        self.Weapon.Visible = false
    end
    
    if ESP.Tracers then
        local tracerStart
        local camera = Workspace.CurrentCamera
        
        if ESP.TracerFrom == "Bottom" then
            tracerStart = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
        elseif ESP.TracerFrom == "Top" then
            tracerStart = Vector2.new(camera.ViewportSize.X / 2, 0)
        elseif ESP.TracerFrom == "Mouse" then
            local mousePos = UserInputService:GetMouseLocation()
            tracerStart = Vector2.new(mousePos.X, mousePos.Y)
        end
        
        -- Трейсер идет к нижней центральной точке бокса
        self.Tracer.From = tracerStart
        self.Tracer.To = Vector2.new(boxPosition.X + boxSize.X / 2, boxPosition.Y + boxSize.Y)
        self.Tracer.Color = espColor
        self.Tracer.Visible = true
        self.Tracer.Transparency = transparency
    else
        self.Tracer.Visible = false
    end
    
    if ESP.LookAt then
        local localPlayer = Players.LocalPlayer
        local localCharacter = localPlayer.Character
        
        if localCharacter and localCharacter:FindFirstChild("Head") then
            local isLooking = IsLookingAtPlayer(character, localCharacter)
             -- Позиция значка "смотрит" над именем
            self.LookingAt.Position = Vector2.new(boxPosition.X + boxSize.X / 2, boxPosition.Y - 30)
            self.LookingAt.Visible = isLooking
            self.LookingAt.Transparency = transparency
        else
            self.LookingAt.Visible = false
        end
    else
        self.LookingAt.Visible = false
    end

    if ESP.HealthBars then
        local healthBarWidth = 5 -- Ширина хелсбара
        local healthBarHeight = boxSize.Y -- Высота равна высоте бокса
         -- Позиция хелсбара слева от бокса
        local healthBarPos = Vector2.new(boxPosition.X - healthBarWidth - 3, boxPosition.Y)

        self.Healthbar.Outline.Size = Vector2.new(healthBarWidth, healthBarHeight)
        self.Healthbar.Outline.Position = healthBarPos
        self.Healthbar.Outline.Visible = true
        self.Healthbar.Outline.Transparency = transparency
        
        local healthScale = humanoid.Health / humanoid.MaxHealth
        -- Заполненная часть хелсбара растет снизу вверх
        local filledHeight = healthBarHeight * healthScale
        self.Healthbar.Main.Size = Vector2.new(healthBarWidth, filledHeight)
        self.Healthbar.Main.Position = Vector2.new(healthBarPos.X, healthBarPos.Y + (healthBarHeight - filledHeight))
        self.Healthbar.Main.Color = Color3.fromRGB(255 * (1 - healthScale), 255 * healthScale, 0)
        self.Healthbar.Main.Visible = true
        self.Healthbar.Main.Transparency = transparency
    else
        self.Healthbar.Outline.Visible = false
        self.Healthbar.Main.Visible = false
    end
    
    if ESP.Skeletons then
        -- Определяем тип риг-модели (R15 или R6)
        local isR15 = character:FindFirstChild("UpperTorso") ~= nil
        
        -- Получаем список всех частей тела (только те, которые нужны для скелета)
        local parts = {
            -- Общие части
            Head = character:FindFirstChild("Head"),
            HumanoidRootPart = character:FindFirstChild("HumanoidRootPart"), -- Добавляем HumanoidRootPart
            
            -- R15 части
            UpperTorso = character:FindFirstChild("UpperTorso"),
            LowerTorso = character:FindFirstChild("LowerTorso"),
            LeftUpperArm = character:FindFirstChild("LeftUpperArm"),
            RightUpperArm = character:FindFirstChild("RightUpperArm"),
            LeftLowerArm = character:FindFirstChild("LeftLowerArm"),
            RightLowerArm = character:FindFirstChild("RightLowerArm"),
            LeftHand = character:FindFirstChild("LeftHand"),
            RightHand = character:FindFirstChild("RightHand"),
            LeftUpperLeg = character:FindFirstChild("LeftUpperLeg"),
            RightUpperLeg = character:FindFirstChild("RightUpperLeg"),
            LeftLowerLeg = character:FindFirstChild("LeftLowerLeg"),
            RightLowerLeg = character:FindFirstChild("RightLowerLeg"),
            LeftFoot = character:FindFirstChild("LeftFoot"),
            RightFoot = character:FindFirstChild("RightFoot"),
            
            -- R6 части
            Torso = character:FindFirstChild("Torso"),
            ["Left Arm"] = character:FindFirstChild("Left Arm"),
            ["Right Arm"] = character:FindFirstChild("Right Arm"),
            ["Left Leg"] = character:FindFirstChild("Left Leg"),
            ["Right Leg"] = character:FindFirstChild("Right Leg")
        }
        
        -- Сбрасываем видимость всех линий скелета
        for _, line in pairs(self.Skeleton) do
            line.Visible = false
        end
        
        -- Функция для отрисовки линии между двумя частями тела (используем HumanoidRootPart если нет торса)
        local function drawLine(line, part1, part2)
            if part1 and part2 then
                local pos1, visible1 = GetRelativePosition(part1.Position)
                local pos2, visible2 = GetRelativePosition(part2.Position)
                
                if visible1 and visible2 then
                    line.From = pos1
                    line.To = pos2
                    line.Color = espColor
                    line.Visible = true
                    line.Transparency = transparency
                end
            end
        end
        
        -- Отрисовка головы к торсу (общая для R15 и R6)
        if parts.Head then
            if isR15 and parts.UpperTorso then
                drawLine(self.Skeleton.Head_Torso, parts.Head, parts.UpperTorso)
            elseif parts.Torso then
                drawLine(self.Skeleton.Head_Torso, parts.Head, parts.Torso)
            elseif parts.HumanoidRootPart then -- Fallback to HumanoidRootPart
                 drawLine(self.Skeleton.Head_Torso, parts.Head, parts.HumanoidRootPart)
            end
        end
        
        if isR15 then
            -- R15 скелетон
            if parts.UpperTorso and parts.LowerTorso then
                drawLine(self.Skeleton.UpperTorso_LowerTorso, parts.UpperTorso, parts.LowerTorso)
            end
            
            -- Руки R15
            if parts.UpperTorso and parts.LeftUpperArm then
                drawLine(self.Skeleton.UpperTorso_LeftUpperArm, parts.UpperTorso, parts.LeftUpperArm)
            end
            
            if parts.UpperTorso and parts.RightUpperArm then
                drawLine(self.Skeleton.UpperTorso_RightUpperArm, parts.UpperTorso, parts.RightUpperArm)
            end
            
            if parts.LeftUpperArm and parts.LeftLowerArm then
                drawLine(self.Skeleton.LeftUpperArm_LeftLowerArm, parts.LeftUpperArm, parts.LeftLowerArm)
            end
            
            if parts.RightUpperArm and parts.RightLowerArm then
                drawLine(self.Skeleton.RightUpperArm_RightLowerArm, parts.RightUpperArm, parts.RightLowerArm)
            end
            
            if parts.LeftLowerArm and parts.LeftHand then
                drawLine(self.Skeleton.LeftLowerArm_LeftHand, parts.LeftLowerArm, parts.LeftHand)
            end
            
            if parts.RightLowerArm and parts.RightHand then
                drawLine(self.Skeleton.RightLowerArm_RightHand, parts.RightLowerArm, parts.RightHand)
            end
            
            -- Ноги R15
            if parts.LowerTorso and parts.LeftUpperLeg then
                drawLine(self.Skeleton.LowerTorso_LeftUpperLeg, parts.LowerTorso, parts.LeftUpperLeg)
            end
            
            if parts.LowerTorso and parts.RightUpperLeg then
                drawLine(self.Skeleton.LowerTorso_RightUpperLeg, parts.LowerTorso, parts.RightUpperLeg)
            end
            
            if parts.LeftUpperLeg and parts.LeftLowerLeg then
                drawLine(self.Skeleton.LeftUpperLeg_LeftLowerLeg, parts.LeftUpperLeg, parts.LeftLowerLeg)
            end
            
            if parts.RightUpperLeg and parts.RightLowerLeg then
                drawLine(self.Skeleton.RightUpperLeg_RightLowerLeg, parts.RightUpperLeg, parts.RightLowerLeg)
            end
            
            if parts.LeftLowerLeg and parts.LeftFoot then
                drawLine(self.Skeleton.LeftLowerLeg_LeftFoot, parts.LeftLowerLeg, parts.LeftFoot)
            end
            
            if parts.RightLowerLeg and parts.RightFoot then
                drawLine(self.Skeleton.RightLowerLeg_RightFoot, parts.RightLowerLeg, parts.RightFoot)
            end
        else
            -- R6 скелетон
            if parts.Torso and parts["Left Arm"] then
                drawLine(self.Skeleton.Torso_LeftArm, parts.Torso, parts["Left Arm"])
            end
            
            if parts.Torso and parts["Right Arm"] then
                drawLine(self.Skeleton.Torso_RightArm, parts.Torso, parts["Right Arm"])
            end
            
            if parts.Torso and parts["Left Leg"] then
                drawLine(self.Skeleton.Torso_LeftLeg, parts.Torso, parts["Left Leg"])
            end
            
            if parts.Torso and parts["Right Leg"] then
                drawLine(self.Skeleton.Torso_RightLeg, parts.Torso, parts["Right Leg"])
            end
        end
    else
        -- Скрываем скелетон если отключен
        for _, line in pairs(self.Skeleton) do
            line.Visible = false
        end
    end

    if ESP.Chams then
        -- Пытаемся применить chams
        pcall(function()
            if not self.Chams then
                self:CreateChams()
            end
            
            self.Chams.Adornee = character
            self.Chams.FillColor = espColor
            self.Chams.OutlineColor = espColor
            self.Chams.FillTransparency = math.min(0.9, 1 - transparency)
            self.Chams.OutlineTransparency = math.min(0.9, 1 - transparency)
            self.Chams.Enabled = true
        end)
    else
        if self.Chams then
            self.Chams.Enabled = false
        end
    end

    if ESP.TeamDisplay and self.Player.Team then
        local teamName = self.Player.Team.Name
        local teamColor = self.Player.Team.TeamColor.Color
        
        self.Team.Text = "[" .. teamName .. "]"
        -- Позиция команды над значком "смотрит", если он виден, иначе над именем
        local teamPosY = boxPosition.Y - (ESP.LookAt and 45 or 30)
        self.Team.Position = Vector2.new(boxPosition.X + boxSize.X / 2, teamPosY)
        self.Team.Color = teamColor
        self.Team.Visible = true
        self.Team.Transparency = transparency
    else
        self.Team.Visible = false
    end
end

function ESPObject:Hide()
    self.Box.Outline.Visible = false
    self.Box.Main.Visible = false
    self.Healthbar.Outline.Visible = false
    self.Healthbar.Main.Visible = false
    self.Name.Visible = false
    self.Team.Visible = false
    self.Distance.Visible = false
    self.Weapon.Visible = false
    self.LookingAt.Visible = false
    self.Tracer.Visible = false
    self.Chams.Enabled = false
    
    -- Hide the skeleton
    for _, line in pairs(self.Skeleton) do
        line.Visible = false
    end
end

function ESPObject:Remove()
    self:Hide()
    
    -- Удаляем соединение с событием CharacterAdded
    if self.CharacterAddedConnection then
        self.CharacterAddedConnection:Disconnect()
        self.CharacterAddedConnection = nil
    end
    
    -- ... остальной существующий код Remove без изменений ...
    if self.Box.Outline then self.Box.Outline:Remove() end
    if self.Box.Main then self.Box.Main:Remove() end
    if self.Healthbar.Outline then self.Healthbar.Outline:Remove() end
    if self.Healthbar.Main then self.Healthbar.Main:Remove() end
    if self.Name then self.Name:Remove() end
    if self.Team then self.Team:Remove() end
    if self.Distance then self.Distance:Remove() end
    if self.Weapon then self.Weapon:Remove() end
    if self.LookingAt then self.LookingAt:Remove() end
    if self.Tracer then self.Tracer:Remove() end
    
    -- Remove the skeleton
    for _, line in pairs(self.Skeleton) do
        if line then line:Remove() end
    end
    
    if self.Chams then self.Chams:Destroy() end
end

local ESPManager = { Objects = {} }
function ESPManager:CreateObject(player)
    if self.Objects[player] then
        self.Objects[player]:Remove()
    end
    self.Objects[player] = ESPObject.new(player)
end

function ESPManager:RemoveObject(player)
    if self.Objects[player] then
        self.Objects[player]:Remove()
        self.Objects[player] = nil
    end
end

function ESPManager:UpdateAll()
    for _, object in pairs(self.Objects) do
        object:Update()
        
        -- Проверка и восстановление чамсов, если они отключены
        if ESP.Enabled and ESP.Chams and object.Player and object.Player.Character then
            if not object.Chams or not object.Chams.Enabled then
                object:CreateChams()
                object:UpdateChamsAdornee(object.Player.Character)
            end
        end
        
        -- Обновление позиции трейсера для режима Mouse
        if ESP.Enabled and ESP.Tracers and ESP.TracerFrom == "Mouse" and object.Tracer and object.Tracer.Visible then
            local mousePos = UserInputService:GetMouseLocation()
            object.Tracer.From = Vector2.new(mousePos.X, mousePos.Y)
        end
    end
end

for _, player in pairs(Players:GetPlayers()) do
    if player ~= Players.LocalPlayer then
        ESPManager:CreateObject(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    ESPManager:CreateObject(player)
end)

Players.PlayerRemoving:Connect(function(player)
    ESPManager:RemoveObject(player)
end)

-- ESPManager update loop
local lastESPUpdateTime = tick() -- Переменная для хранения времени последнего обновления ESP
local espUpdateInterval = 0.03 -- Интервал обновления в секундах (0.01 секунды)

-- Меняем подключение к RenderStepped для контроля частоты обновления
-- ESPManager update loop
-- RunService.RenderStepped:Connect(function() -- Закомментируем или удалим старое подключение
--     ESPManager:UpdateAll()
-- end)

-- Новое подключение с контролем частоты
if _G.ESPUpdateConnection then -- Проверяем, существует ли уже соединение, чтобы избежать дублирования
    _G.ESPUpdateConnection:Disconnect()
    _G.ESPUpdateConnection = nil
end

_G.ESPUpdateConnection = RunService.RenderStepped:Connect(function()
    local currentTime = tick() -- Получаем текущее время
    
    -- Проверяем, прошло ли достаточно времени с момента последнего обновления
    if currentTime - lastESPUpdateTime >= espUpdateInterval then
        -- Выполняем обновление ESP
    ESPManager:UpdateAll()
        
        -- Обновляем время последнего обновления
        lastESPUpdateTime = currentTime
    end
end)

-- Create sections for ESP
local GeneralSection = ESPTab:CreateSection("General Settings")

ESPTab:CreateToggle({
    Name = "Enable ESP",
    CurrentValue = false,
    Flag = "EnableESP",
    Callback = function(Value)
        ESP.Enabled = Value
        -- Убираем автоматическую установку ShowTeammates
        -- ESP.ShowTeammates = Value
    end
})

ESPTab:CreateToggle({
    Name = "Team Check",
    CurrentValue = false,
    Flag = "TeamCheck",
    Callback = function(Value)
        ESP.TeamCheck = Value
        
        -- Устанавливаем ShowTeammates в false при включении проверки команд
        if Value then
            ESP.ShowTeammates = false
            Rayfield:Notify({
                Title = "Teams",
                Content = "Players from your team will be hidden",
                Duration = 2,
                Image = 4483345998
            })
        else
            ESP.ShowTeammates = true
            Rayfield:Notify({
                Title = "Teams",
                Content = "All players will be displayed",
                Duration = 2,
                Image = 4483345998
            })
        end
    end
})

ESPTab:CreateToggle({
    Name = "Team Color",
    CurrentValue = false,
    Flag = "TeamColor",
    Callback = function(Value)
        ESP.TeamColor = Value
    end
})

ESPTab:CreateColorPicker({
    Name = "ESP Color",
    Color = Color3.fromRGB(255, 255, 255),
    Flag = "ESPColor",
    Callback = function(Value)
        ESP.Color = Value
    end
})

ESPTab:CreateToggle({
    Name = "Rainbow Color",
    CurrentValue = false,
    Flag = "RainbowColor",
    Callback = function(Value)
        ESP.RainbowColor = Value
    end
})

ESPTab:CreateSlider({
    Name = "Rainbow Speed",
    Range = {0.01, 5},
    Increment = 0.01,
    Suffix = "x",
    CurrentValue = 1,
    Flag = "RainbowSpeed",
    Callback = function(Value)
        ESP.Rainbow.Speed = Value
    end
})

ESPTab:CreateSlider({
    Name = "Transparency",
    Range = {0, 1},
    Increment = 0.1,
    Suffix = "%",
    CurrentValue = 1,
    Flag = "Transparency",
    Callback = function(Value)
        ESP.Transparency = Value
    end
})

ESPTab:CreateSlider({
    Name = "Maximum Distance",
    Range = {100, 10000},
    Increment = 100,
    Suffix = "m",
    CurrentValue = 10000,
    Flag = "MaxDistance",
    Callback = function(Value)
        ESP.MaxDistance = Value
    end
})

local ElementsSection = ESPTab:CreateSection("ESP Elements")

ESPTab:CreateToggle({
    Name = "Boxes",
    CurrentValue = false,
    Flag = "Boxes",
    Callback = function(Value)
        ESP.Boxes = Value
    end
})

ESPTab:CreateToggle({
    Name = "Health",
    CurrentValue = false,
    Flag = "Health",
    Callback = function(Value)
        ESP.HealthBars = Value
    end
})

ESPTab:CreateToggle({
    Name = "Names",
    CurrentValue = false,
    Flag = "Names",
    Callback = function(Value)
        ESP.Names = Value
    end
})
--[[
ESPTab:CreateToggle({
    Name = "Teams",
    CurrentValue = false,
    Flag = "Teams",
    Callback = function(Value)
        ESP.TeamDisplay = Value
    end
})
]]

ESPTab:CreateToggle({
    Name = "Distance",
    CurrentValue = false,
    Flag = "Distance",
    Callback = function(Value)
        ESP.Distance = Value
    end
})

ESPTab:CreateToggle({
    Name = "Chams",
    CurrentValue = false,
    Flag = "Chams",
    Callback = function(Value)
        ESP.Chams = Value
        
        -- При включении Chams обновляем все объекты немедленно
        if Value then
            Rayfield:Notify({
                Title = "Chams Enabled",
                Content = "Wall-hack highlighting activated!",
                Duration = 2,
                Image = 4483345998
            })
            
            -- Пересоздаем Chams для всех игроков
            for _, object in pairs(ESPManager.Objects) do
                if object.Player then
                    object:CreateChams()
                    if object.Player.Character then
                        object:UpdateChamsAdornee(object.Player.Character)
                    end
                end
            end
        else
            -- Отключаем все чамсы
            for _, object in pairs(ESPManager.Objects) do
                if object.Chams then
                    object.Chams.Enabled = false
                end
            end
            
            Rayfield:Notify({
                Title = "Chams Disabled",
                Content = "Wall-hack highlighting deactivated",
                Duration = 2,
                Image = 4483345998
            })
        end
    end
})


ESPTab:CreateToggle({
    Name = "Skeletons",
    CurrentValue = false,
    Flag = "Skeletons",
    Callback = function(Value)
        ESP.Skeletons = Value
    end
})

ESPTab:CreateToggle({
    Name = "Weapon",
    CurrentValue = false,
    Flag = "Weapon",
    Callback = function(Value)
        ESP.Weapon = Value
    end
})

ESPTab:CreateToggle({
    Name = "Tracers",
    CurrentValue = false,
    Flag = "Tracers",
    Callback = function(Value)
        ESP.Tracers = Value
        
        -- При включении трейсеров сразу применяем настройки положения
        if Value then
            local camera = Workspace.CurrentCamera
            local tracerStart
            
            -- Определяем начальную точку в зависимости от настройки
            if ESP.TracerFrom == "Bottom" then
                tracerStart = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
            elseif ESP.TracerFrom == "Top" then
                tracerStart = Vector2.new(camera.ViewportSize.X / 2, 0)
            elseif ESP.TracerFrom == "Mouse" then
                local mousePos = UserInputService:GetMouseLocation()
                tracerStart = Vector2.new(mousePos.X, mousePos.Y)
            end
            
            -- Применяем начальную точку ко всем объектам
            for _, object in pairs(ESPManager.Objects) do
                if object.Tracer then
                    object.Tracer.From = tracerStart
                end
            end
            
            local originType = type(ESP.TracerFrom) == "string" and ESP.TracerFrom or "Default"
            
            Rayfield:Notify({
                Title = "Tracers",
                Content = "Tracers enabled with origin: " .. originType,
                Duration = 2,
                Image = 4483345998
            })
        end
    end
})

ESPTab:CreateDropdown({
    Name = "Tracer Origin",
    Options = {"Bottom", "Top", "Mouse"},
    CurrentOption = "Bottom",
    Flag = "TracerOrigin",
    Callback = function(Value)
        local originValue = ""
        if type(Value) == "table" then
            originValue = tostring(Value[1] or "Unknown")
        else
            originValue = tostring(Value)
        end
        
        if originValue == "Bottom" then
            ESP.TracerFrom = "Bottom"
        elseif originValue == "Top" then
            ESP.TracerFrom = "Top"
        elseif originValue == "Mouse" then
            ESP.TracerFrom = "Mouse"
        end
        
        -- Применяем изменения сразу для всех существующих трейсеров
        for _, object in pairs(ESPManager.Objects) do
            if object.Tracer and object.Tracer.Visible and ESP.Tracers then
                local camera = Workspace.CurrentCamera
                local tracerStart
                
                if ESP.TracerFrom == "Bottom" then
                    tracerStart = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
                elseif ESP.TracerFrom == "Top" then
                    tracerStart = Vector2.new(camera.ViewportSize.X / 2, 0)
                elseif ESP.TracerFrom == "Mouse" then
                    local mousePos = UserInputService:GetMouseLocation()
                    tracerStart = Vector2.new(mousePos.X, mousePos.Y)
                end
                
                object.Tracer.From = tracerStart
            end
        end
        
        -- Показываем уведомление об изменении
        Rayfield:Notify({
            Title = "Tracer Origin",
            Content = "Tracer origin set to " .. originValue,
            Duration = 2,
            Image = 4483345998
        })
    end,
})

ESPTab:CreateToggle({
    Name = "Text Outline",
    CurrentValue = true,
    Flag = "TextOutline",
    Callback = function(Value)
        ESP.TextOutline = Value
        for _, object in pairs(ESPManager.Objects) do
            if object.Name then object.Name.Outline = Value end
            if object.Distance then object.Distance.Outline = Value end
            if object.Weapon then object.Weapon.Outline = Value end
        end
    end
})

local PlayerTab = Window:CreateTab("Player", 6022668898)

local CameraSection = PlayerTab:CreateSection("Camera")
local savedFov   = 70
local defaultFov = Workspace.CurrentCamera.FieldOfView
local isAdjusting  = false

PlayerTab:CreateButton({
    Name = "Reset FOV",
    Callback = function()
        Workspace.CurrentCamera.FieldOfView = defaultFov
        savedFov = defaultFov
    end
})

PlayerTab:CreateSlider({
    Name = "FOV",
    Range = {10, 120},
    Increment = 1,
    Suffix = "FOV",
    CurrentValue = defaultFov,
    Flag = "FOVValue",
    Callback = function(Value)
        Workspace.CurrentCamera.FieldOfView = Value
        savedFov = Value
        isAdjusting = true
    end
})

PlayerTab:CreateButton({
    Name = "Infinite Zoom",
    Callback = function()
        Players.LocalPlayer.CameraMaxZoomDistance = 99999999
    end
})

local ZoomSection = PlayerTab:CreateSection("Zoom-hack")
local zoomEnabled   = false
local zoomStrength  = 2
local isZooming     = false
local zoomFov       = 70

PlayerTab:CreateToggle({
    Name = "zoom on Z",
    CurrentValue = false,
    Flag = "ZoomEnabled",
    Callback = function(Value)
        zoomEnabled = Value
        if not Value and isZooming then
            Workspace.CurrentCamera.FieldOfView = savedFov
            isZooming = false
        end
    end
})

PlayerTab:CreateSlider({
    Name = "Zoom Strength",
    Range = {1.1, 10},
    Increment = 0.1,
    Suffix = "x",
    CurrentValue = 2,
    Flag = "ZoomStrength",
    Callback = function(Value)
        zoomStrength = Value
        if isZooming then
            Workspace.CurrentCamera.FieldOfView = zoomFov / zoomStrength
        end
    end
})

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and zoomEnabled and input.KeyCode == Enum.KeyCode.Z then
        zoomFov = Workspace.CurrentCamera.FieldOfView
        Workspace.CurrentCamera.FieldOfView = zoomFov / zoomStrength
        isZooming = true
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if not gameProcessed and zoomEnabled and input.KeyCode == Enum.KeyCode.Z and isZooming then
        Workspace.CurrentCamera.FieldOfView = savedFov
        isZooming = false
    end
end)

PlayerTab:CreateButton({
    Name = "free cam (shift + p)",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/Rollimonster/Roblox-FreeCam-Script/refs/heads/main/Roblox-FreeCam-Script'))()
    end
})

local MovementSection = PlayerTab:CreateSection("Movement Settings")
PlayerTab:CreateSlider({
    Name = "Movement Speed",
    Range = {0, 200},
    Increment = 0.5,
    Suffix = "Speed",
    CurrentValue = 0,
    Flag = "SpeedValue",
    Callback = function(Value)
        getgenv().Speed = Value
    end
})

PlayerTab:CreateToggle({
    Name = "Enable",
    CurrentValue = false,
    Flag = "SpeedEnabled",
    Callback = function(Value)
        getgenv().TpWalking = Value
        Rayfield:Notify({
            Title = "Speed",
            Content = Value and "Speed enabled" or "Speed disabled",
            Duration = 3,
            Image = 4483345998
        })
    end
})

local tpWalkConnection = nil
getgenv().TpWalking = false
getgenv().Speed = 0
local function setupTeleportWalking(character)
    if tpWalkConnection then tpWalkConnection:Disconnect() end
    local humanoid = character:WaitForChild("Humanoid")
    local rootPart = character:WaitForChild("HumanoidRootPart")
    tpWalkConnection = RunService.Heartbeat:Connect(function()
        if getgenv().TpWalking and humanoid and humanoid.Parent then
            if humanoid.MoveDirection.Magnitude > 0 then
                local ray = Ray.new(rootPart.Position, humanoid.MoveDirection.Unit * 2)
                local hit = Workspace:FindPartOnRayWithIgnoreList(ray, {character})
                if not hit then
                    local delta = RunService.Heartbeat:Wait()
                    local moveDirection = humanoid.MoveDirection.Unit * getgenv().Speed * delta
                    character:TranslateBy(moveDirection)
                end
            end
        end
    end)
end
Players.LocalPlayer.CharacterAdded:Connect(setupTeleportWalking)
if Players.LocalPlayer.Character then
    setupTeleportWalking(Players.LocalPlayer.Character)
end

local FlightSection = PlayerTab:CreateSection("Flight")
local Flying = false
local FlightSpeed = 50   
local VerticalSpeed = 50 
local flyConnection
local camera = Workspace.CurrentCamera
local baseY 

local function startFlight()
    local player = Players.LocalPlayer
    local character = player and player.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not hrp or not humanoid then return end

    -- Проверяем, находится ли игрок в транспортном средстве
    local isInVehicle = humanoid.SeatPart and humanoid.SeatPart:IsA("VehicleSeat")
    local vehiclePart = nil
    
    if isInVehicle then
        -- Находим основную часть транспортного средства
        local vehicleSeat = humanoid.SeatPart
        vehiclePart = vehicleSeat -- Временно используем само сиденье как часть

        -- Сначала пытаемся получить доступ к модели машины напрямую через иерархию
        if vehicleSeat.Parent and vehicleSeat.Parent:IsA("Model") then
            local vehicleModel = vehicleSeat.Parent
            
            -- Пробуем найти основную часть в модели
            vehiclePart = vehicleModel.PrimaryPart or 
                          vehicleModel:FindFirstChild("Root") or 
                          vehicleModel:FindFirstChild("Body") or 
                          vehicleModel:FindFirstChild("Main") or
                          vehiclePart
            
            -- Если не нашли основную часть, ищем любую BasePart
            if not vehiclePart or not vehiclePart:IsA("BasePart") then
                for _, part in pairs(vehicleModel:GetDescendants()) do
                    if part:IsA("BasePart") and part ~= vehicleSeat then
                        vehiclePart = part
                        break
                    end
                end
            end
            
            -- Если это машина игрока по типу workspace.im11062323sCar.Body
            if not vehiclePart:IsA("BasePart") then
                -- Пробуем найти машину игрока в воркспейсе
                local playerCar = workspace:FindFirstChild(player.Name .. "sCar")
                if playerCar and playerCar:IsA("Model") then
                    vehiclePart = playerCar.PrimaryPart or 
                                  playerCar:FindFirstChild("Body") or 
                                  playerCar:FindFirstChild("Root") or
                                  playerCar:FindFirstChild("DriveSeat")
                    
                    if not vehiclePart or not vehiclePart:IsA("BasePart") then
                        for _, part in pairs(playerCar:GetDescendants()) do
                            if part:IsA("BasePart") then
                                vehiclePart = part
                                break
                            end
                        end
                    end
                end
            end
        end
        
        -- Если всё ещё не нашли часть, используем само сиденье
        if not vehiclePart or not vehiclePart:IsA("BasePart") then
            vehiclePart = vehicleSeat
        end
    end
    
    humanoid.PlatformStand = not isInVehicle -- Только если игрок не в транспорте
    baseY = hrp.Position.Y

    flyConnection = RunService.RenderStepped:Connect(function(delta)
        local moveDir = Vector3.new(0, 0, 0)
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            moveDir = moveDir + camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            moveDir = moveDir - camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            moveDir = moveDir - camera.CFrame.RightVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            moveDir = moveDir + camera.CFrame.RightVector
        end
        
        -- Убираем Y-компонент из moveDir для горизонтального движения
        if moveDir.Magnitude > 0 then
            -- Для машины сохраняем направление по Y, чтобы машина двигалась по земле
            if isInVehicle then
                moveDir = Vector3.new(moveDir.X, 0, moveDir.Z).Unit
            else
                moveDir = moveDir.Unit
            end
        end

        local speedMultiplier = 1
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            speedMultiplier = 2
        end

        local verticalInput = 0
        if UserInputService:IsKeyDown(Enum.KeyCode.E) then
            verticalInput = VerticalSpeed
        elseif UserInputService:IsKeyDown(Enum.KeyCode.Q) then
            verticalInput = -VerticalSpeed
        end

        local pos
        if isInVehicle and vehiclePart then
            -- Управляем транспортным средством
            pos = vehiclePart.Position
        else
            -- Управляем персонажем
            pos = hrp.Position
        end
        
        local horizontalOffset = moveDir * FlightSpeed * speedMultiplier * delta
        
        local newX = pos.X + horizontalOffset.X
        local newZ = pos.Z + horizontalOffset.Z
        local newY
        if verticalInput ~= 0 then
            newY = pos.Y + verticalInput * speedMultiplier * delta
            baseY = newY 
        else
            newY = baseY 
        end

        local newPos = CFrame.new(newX, newY, newZ)
        
        if isInVehicle and vehiclePart then
            -- Перехватываем ошибку доступа к Position свойству
            pcall(function()
                -- Создаем CFrame, который смотрит в направлении движения
                local lookAtDirection = moveDir
                if lookAtDirection.Magnitude > 0 then
                    -- Сохраняем текущую высоту и создаем новый CFrame, направленный в сторону движения
                    local vehicleHeight = vehiclePart.Position.Y
                    local targetPoint = vehiclePart.Position + lookAtDirection * 10
                    targetPoint = Vector3.new(targetPoint.X, vehicleHeight, targetPoint.Z)
                    
                    -- Устанавливаем новый CFrame с поворотом в сторону движения
                    local newCFrame = CFrame.lookAt(newPos.Position, targetPoint)
                    
                    -- Плавное перемещение с поворотом
                    local currentCFrame = vehiclePart.CFrame
                    local blendAlpha = 0.1 -- Коэффициент плавности (0-1)
                    
                    -- Сохраняем текущий угол наклона (по X и Z)
                    local _, currentRY, _ = currentCFrame:ToOrientation()
                    local targetX, targetY, targetZ = newCFrame:ToOrientation()
                    
                    -- Создаем CFrame только с поворотом по Y (игнорируем наклоны)
                    local adjustedCFrame = CFrame.new(newPos.Position) * CFrame.Angles(0, targetY, 0)
                    
                    -- Применяем ускорение
                    vehiclePart.AssemblyLinearVelocity = (newPos.Position - vehiclePart.Position) / delta
                    -- Применяем поворот плавно
                    vehiclePart.CFrame = currentCFrame:Lerp(adjustedCFrame, blendAlpha)
                    -- Стабилизируем машину (предотвращаем кувыркание)
                    vehiclePart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                else
                    -- Если нет направления, просто перемещаем без поворота
                    vehiclePart.AssemblyLinearVelocity = (newPos.Position - vehiclePart.Position) / delta
                    vehiclePart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end
            end)
        else
            -- Двигаем персонажа
            hrp.CFrame = newPos
            hrp.Velocity = Vector3.new(0, 0, 0)
            hrp.RotVelocity = Vector3.new(0, 0, 0)
        end
    end)
end

local function stopFlight()
    local player = Players.LocalPlayer
    local character = player and player.Character
    if character then
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            -- Проверяем, находится ли игрок в транспортном средстве
            local isInVehicle = humanoid.SeatPart and humanoid.SeatPart:IsA("VehicleSeat")
            
            if not isInVehicle then
                humanoid.PlatformStand = false
            end
            
            -- Если игрок в транспорте, останавливаем его
            if isInVehicle then
                local vehicleSeat = humanoid.SeatPart
                local vehiclePart = nil
                
                -- Сначала пытаемся получить доступ к модели машины напрямую через иерархию
                if vehicleSeat.Parent and vehicleSeat.Parent:IsA("Model") then
                    local vehicleModel = vehicleSeat.Parent
                    
                    -- Пробуем найти основную часть в модели
                    vehiclePart = vehicleModel.PrimaryPart or 
                                  vehicleModel:FindFirstChild("Root") or 
                                  vehicleModel:FindFirstChild("Body") or 
                                  vehicleModel:FindFirstChild("Main") or
                                  vehicleSeat
                    
                    -- Если не нашли основную часть, ищем любую BasePart
                    if not vehiclePart or not vehiclePart:IsA("BasePart") then
                        for _, part in pairs(vehicleModel:GetDescendants()) do
                            if part:IsA("BasePart") and part ~= vehicleSeat then
                                vehiclePart = part
                                break
                            end
                        end
                    end
                    
                    -- Если это машина игрока по типу workspace.im11062323sCar.Body
                    if not vehiclePart:IsA("BasePart") then
                        -- Пробуем найти машину игрока в воркспейсе
                        local playerCar = workspace:FindFirstChild(player.Name .. "sCar")
                        if playerCar and playerCar:IsA("Model") then
                            vehiclePart = playerCar.PrimaryPart or 
                                          playerCar:FindFirstChild("Body") or 
                                          playerCar:FindFirstChild("Root") or
                                          playerCar:FindFirstChild("DriveSeat")
                            
                            if not vehiclePart or not vehiclePart:IsA("BasePart") then
                                for _, part in pairs(playerCar:GetDescendants()) do
                                    if part:IsA("BasePart") then
                                        vehiclePart = part
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
                
                -- Если всё ещё не нашли часть, используем само сиденье
                if not vehiclePart or not vehiclePart:IsA("BasePart") then
                    vehiclePart = vehicleSeat
                end
                
                -- Останавливаем транспортное средство
                if vehiclePart and vehiclePart:IsA("BasePart") then
                    pcall(function()
                        vehiclePart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        vehiclePart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    end)
                end
            end
        end
    end
    if flyConnection then
        flyConnection:Disconnect()
        flyConnection = nil
    end
end

PlayerTab:CreateToggle({
    Name = "Flight",
    CurrentValue = false,
    Flag = "FlightEnabled",
    Callback = function(Value)
        Flying = Value -- Сначала установим значение Flying
        if Value then -- Если пытаемся включить полет
            startFlight() -- Удаляем проверку на нахождение в транспорте
            Rayfield:Notify({
                Title = "Flight",
                Content = "Flight enabled",
                Duration = 3,
                Image = 4483345998
            })
        else
            stopFlight()
            Rayfield:Notify({
                Title = "Flight",
                Content = "Flight disabled",
                Duration = 3,
                Image = 4483345998
            })
        end
    end
})

PlayerTab:CreateSlider({
    Name = "Flight Speed",
    Range = {0, 500},
    Increment = 1,
    Suffix = " speed",
    CurrentValue = FlightSpeed,
    Flag = "FlightSpeed",
    Callback = function(Value)
        FlightSpeed = Value
    end
})

PlayerTab:CreateSlider({
    Name = "Vertical Speed",
    Range = {0, 500},
    Increment = 1,
    Suffix = " speed",
    CurrentValue = VerticalSpeed,
    Flag = "FlightVerticalSpeed",
    Callback = function(Value)
        VerticalSpeed = Value
    end
})

local JumpSection = PlayerTab:CreateSection("Jump")
PlayerTab:CreateSlider({
    Name = "Jump Power",
    Range = {1, 60},
    Increment = 1,
    Suffix = "Jump Power",
    CurrentValue = 45,
    Flag = "JumpPower",
    Callback = function(Value)
        local player = Players.LocalPlayer
        local connection
        local function setJumpPower(character)
            if character and character:FindFirstChild("Humanoid") then
                character.Humanoid.JumpPower = Value
            end
        end
        if connection then connection:Disconnect() end
        if player.Character then
            setJumpPower(player.Character)
        end
        connection = player.CharacterAdded:Connect(function(character)
            setJumpPower(character)
            local humanoid = character:WaitForChild("Humanoid")
            humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
                if humanoid.JumpPower ~= Value then
                    humanoid.JumpPower = Value
                end
            end)
        end)
    end
})

PlayerTab:CreateToggle({
    Name = "Infinite Jumps",
    CurrentValue = false,
    Flag = "InfiniteJump",
    Callback = function(Value)
        local Player = Players.LocalPlayer
        local UIS = UserInputService
        _G.JumpHeight = 50
        _G.IsJumpEnabled = Value
        UIS.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space then
                local character = Player.Character
                if _G.IsJumpEnabled and character and character:FindFirstChild("Humanoid") then
                    if character.Humanoid:GetState() == Enum.HumanoidStateType.Jumping or character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                        local hrp = character:FindFirstChild("HumanoidRootPart")
                        if hrp then hrp.Velocity = Vector3.new(0, _G.JumpHeight, 0) end
                    end
                end
            end
        end)
    end
})

PlayerTab:CreateToggle({
    Name = "Disable Jump Cooldown",
    CurrentValue = false,
    Flag = "DisableJumpCooldown",
    Callback = function(Value)
        local player = Players.LocalPlayer
        local function disableJumpCooldown(character)
            if character then
                local jumpCooldown = character:FindFirstChild("JumpCooldown")
                if jumpCooldown then
                    jumpCooldown.Disabled = Value
                    Rayfield:Notify({
                        Title = "Jump Cooldown",
                        Content = Value and "Jump cooldown disabled" or "Jump cooldown enabled",
                        Duration = 3,
                        Image = 4483345998
                    })
                end
            end
        end
        if player.Character then
            disableJumpCooldown(player.Character)
        end
        player.CharacterAdded:Connect(function(newCharacter)
            task.wait(0.5)
            disableJumpCooldown(newCharacter)
        end)
    end
})

local TpToolSection = PlayerTab:CreateSection("TpTool")
PlayerTab:CreateButton({
    Name = "TpTool",
    Callback = function()
        local player = Players.LocalPlayer
        local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local tool = Instance.new("Tool", player.Backpack)
            local mouse = player:GetMouse()
            tool.Name = "click tp"
            tool.RequiresHandle = false
            tool.Activated:Connect(function()
                hrp.CFrame = CFrame.new(mouse.Hit.Position + Vector3.new(0,4,0))
            end)
        end
    end
})

local CtrlClickSection = PlayerTab:CreateSection("CtrlClickDelete")
PlayerTab:CreateButton({
    Name = "CtrlClickDelete",
    Callback = function()
        local Mouse = Players.LocalPlayer:GetMouse()
        Mouse.Button1Down:Connect(function()
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) and Mouse.Target then
                Mouse.Target:Destroy()
            end
        end)
    end
})

-- Новая секция и кнопка для подбрасывания машины
PlayerTab:CreateSection("VehicleFling") 

PlayerTab:CreateButton({
    Name = "Fling Car",
    Callback = function()
        print("[Fling Car DEBUG] Button pressed")
        local player = Players.LocalPlayer
        if not player then 
            print("[Fling Car DEBUG] Player not found")
            return 
        end

        local character = player.Character
        if not character or not character:FindFirstChildOfClass("Humanoid") then
            Rayfield:Notify({Title = "Car Fling", Content = "Player character or Humanoid not found.", Duration = 3, Image = 4483345998})
            print("[Fling Car DEBUG] Character or Humanoid not found")
            return
        end
        
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then
             Rayfield:Notify({Title = "Car Fling", Content = "HumanoidRootPart not found.", Duration = 3, Image = 4483345998})
             print("[Fling Car DEBUG] HumanoidRootPart not found")
            return
        end

        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid.SeatPart or not humanoid.SeatPart:IsA("VehicleSeat") then
            Rayfield:Notify({Title = "Car Fling", Content = "You need to be in a VehicleSeat.", Duration = 3, Image = 4483345998})
            print("[Fling Car DEBUG] Not in a VehicleSeat")
            return
        end

        local vehicleSeat = humanoid.SeatPart
        local vehicleToFling = nil
        local vehicleModel = vehicleSeat:FindFirstAncestorWhichIsA("Model")
        print("[Fling Car DEBUG] VehicleSeat: " .. vehicleSeat:GetFullName())

        if vehicleModel then
            print("[Fling Car DEBUG] Found vehicle model: " .. vehicleModel:GetFullName())
            if vehicleModel.PrimaryPart and vehicleModel.PrimaryPart:IsA("BasePart") then
                vehicleToFling = vehicleModel.PrimaryPart
                print("[Fling Car DEBUG] Using model's PrimaryPart: " .. vehicleToFling:GetFullName())
            else
                print("[Fling Car DEBUG] Model has no PrimaryPart or it's not a BasePart. Searching for alternatives...")
                local mainPartNames = {"Chassis", "Body", "DriveSeat", "Main", "Frame"}
                for _, nameKey in ipairs(mainPartNames) do
                    local potentialPart = vehicleModel:FindFirstChild(nameKey, true) 
                    if potentialPart and potentialPart:IsA("BasePart") then
                        vehicleToFling = potentialPart
                        print("[Fling Car DEBUG] Found part by name: " .. vehicleToFling:GetFullName())
                        break
                    end
                end
                if not vehicleToFling then
                    print("[Fling Car DEBUG] No part found by common names. Searching for any BasePart descendant...")
                    for _, partDescendant in ipairs(vehicleModel:GetDescendants()) do
                        if partDescendant:IsA("BasePart") and partDescendant ~= vehicleSeat and partDescendant.Name ~= "HumanoidRootPart" then
                            vehicleToFling = partDescendant
                            print("[Fling Car DEBUG] Found descendant BasePart: " .. vehicleToFling:GetFullName())
                            break
                        end
                    end
                end
            end
        else
            print("[Fling Car DEBUG] No model ancestor found for VehicleSeat.")
        end
        
        if not vehicleToFling and vehicleSeat.Parent and vehicleSeat.Parent:IsA("BasePart") and vehicleSeat.Parent ~= character then
            vehicleToFling = vehicleSeat.Parent
            print("[Fling Car DEBUG] Using VehicleSeat's parent part: " .. vehicleToFling:GetFullName())
        end

        if not vehicleToFling and vehicleSeat:IsA("BasePart") then
            vehicleToFling = vehicleSeat
             print("[Fling Car DEBUG] Using VehicleSeat itself as the part: " .. vehicleToFling:GetFullName())
        end

        if not vehicleToFling or not vehicleToFling:IsA("BasePart") then
            Rayfield:Notify({Title = "Car Fling", Content = "Could not find a valid part of the vehicle to fling.", Duration = 3, Image = 4483345998})
            print("[Fling Car DEBUG] Failed to find any valid part to fling.")
            return
        end

        print("[Fling Car DEBUG] Final target part: " .. vehicleToFling:GetFullName())
        print("[Fling Car DEBUG] Anchored: " .. tostring(vehicleToFling.Anchored))
        print("[Fling Car DEBUG] Mass: " .. tostring(vehicleToFling:GetMass()))
        if vehicleToFling.Parent then
             print("[Fling Car DEBUG] Target part's Parent: " .. vehicleToFling.Parent:GetFullName())
        end
        Rayfield:Notify({Title = "Car Fling Debug", Content = "Preparing to fling: " .. vehicleToFling.Name, Duration = 3})

        local upwardVelocity = 200  
        local forwardVelocity = 150 

        local lookVector = humanoidRootPart.CFrame.LookVector
        local flingVelocity = Vector3.new(lookVector.X * forwardVelocity, upwardVelocity, lookVector.Z * forwardVelocity)
        print("[Fling Car DEBUG] Calculated Fling Velocity: " .. tostring(flingVelocity))
        
        vehicleToFling.AssemblyLinearVelocity = flingVelocity
        
        Rayfield:Notify({Title = "Car Fling", Content = "Vehicle flung command executed!", Duration = 3, Image = 4483345998})
        print("[Fling Car DEBUG] Fling command executed on: " .. vehicleToFling:GetFullName())
    end
})

-- Car Speedhack
local carSpeedEnabled = false
local carSpeedFactor = 1.0 -- Теперь это множитель дополнительной скорости
local carSpeedLoop = nil
local lastVehicleSpeed = 0 -- Для отслеживания, если понадобится

PlayerTab:CreateSection("Vehicle Speed Control")

PlayerTab:CreateToggle({
    Name = "Enable Car Accelerator", -- Переименовано для ясности
    CurrentValue = false,
    Flag = "CarSpeedhackEnabled", -- Флаг можно оставить
    Callback = function(Value)
        carSpeedEnabled = Value
        if carSpeedEnabled then
            if carSpeedLoop then carSpeedLoop:Disconnect() end

            carSpeedLoop = RunService.Heartbeat:Connect(function()
                if not carSpeedEnabled then return end

                local player = Players.LocalPlayer
                local char = player and player.Character
                if not (char and char.Parent) then return end
                local hum = char:FindFirstChildOfClass("Humanoid")
                if not (hum and hum.Parent) then return end

                if hum.SeatPart and hum.SeatPart:IsA("VehicleSeat") then
                    local vehicleSeat = hum.SeatPart
                    local vehiclePartToBoost = nil
                    local vehicleModel = vehicleSeat:FindFirstAncestorWhichIsA("Model")

                    -- Логика поиска основной части машины (аналогично Fling Car)
                    if vehicleModel then
                        if vehicleModel.PrimaryPart and vehicleModel.PrimaryPart:IsA("BasePart") then
                            vehiclePartToBoost = vehicleModel.PrimaryPart
                        else
                            local mainPartNames = {"Chassis", "Body", "Frame", "DriveSeat"} -- Основные имена частей, на которые стоит ориентироваться
                            for _, nameKey in ipairs(mainPartNames) do
                                local potentialPart = vehicleModel:FindFirstChild(nameKey, true)
                                if potentialPart and potentialPart:IsA("BasePart") then
                                    vehiclePartToBoost = potentialPart
                                    break
                                end
                            end
                            if not vehiclePartToBoost then -- Если не нашли по специфичным именам, ищем тяжелую часть
                                for _, partDescendant in ipairs(vehicleModel:GetDescendants()) do
                                    if partDescendant:IsA("BasePart") and partDescendant ~= vehicleSeat and partDescendant.Name ~= "HumanoidRootPart" and partDescendant.AssemblyMass > 5 then 
                                        vehiclePartToBoost = partDescendant
                                        break
                                    end
                                end
                            end
                        end
                    end
                    -- Если не нашли в модели, пробуем родителя сиденья
                    if not vehiclePartToBoost and vehicleSeat.Parent and vehicleSeat.Parent:IsA("BasePart") and vehicleSeat.Parent ~= char then
                        vehiclePartToBoost = vehicleSeat.Parent
                    end
                    -- В крайнем случае, если сиденье - это и есть основная часть
                     if not vehiclePartToBoost and vehicleSeat:IsA("BasePart") then 
                        vehiclePartToBoost = vehicleSeat
                    end

                    if vehiclePartToBoost and vehiclePartToBoost:IsA("BasePart") and not vehiclePartToBoost.Anchored then
                        local forwardVector = vehicleSeat.CFrame.LookVector -- Направление вперед для машины
                        local throttle = vehicleSeat.ThrottleFloat -- От -1 (назад) до 1 (вперед), 0 - нет газа
                        
                        if throttle ~= 0 then -- Ускоряем только если игрок нажимает газ/тормоз(реверс)
                            -- Сила ускорения. 75 - новое базовое значение, carSpeedFactor - множитель.
                            local boostStrength = 75 -- Увеличено с 50
                            local additionalVelocity = forwardVector * boostStrength * carSpeedFactor * throttle * (RunService.Heartbeat:Wait()) -- Умножаем на дельту времени для плавности
                            
                            vehiclePartToBoost.AssemblyLinearVelocity = vehiclePartToBoost.AssemblyLinearVelocity + additionalVelocity
                           
                           -- Опциональное ограничение максимальной скорости, чтобы избежать слишком неконтролируемого поведения
                           local dynamicMaxSpeed = 200 + (150 * carSpeedFactor) -- Новая формула: (база 200, +150 за каждый уровень фактора)
                           if vehiclePartToBoost.AssemblyLinearVelocity.Magnitude > dynamicMaxSpeed then
                               vehiclePartToBoost.AssemblyLinearVelocity = vehiclePartToBoost.AssemblyLinearVelocity.Unit * dynamicMaxSpeed
                           end
                        end
                        lastVehicleSpeed = vehiclePartToBoost.AssemblyLinearVelocity.Magnitude
                    end
                else
                    lastVehicleSpeed = 0
                end
            end)
            Rayfield:Notify({Title = "Car Accelerator", Content = "Enabled (Factor: " .. string.format("%.1f", carSpeedFactor) .. "x)", Duration = 3, Image = 4483345998})
        else
            if carSpeedLoop then
                carSpeedLoop:Disconnect()
                carSpeedLoop = nil
            end
            lastVehicleSpeed = 0
            Rayfield:Notify({Title = "Car Accelerator", Content = "Disabled", Duration = 3, Image = 4483345998})
        end
    end
})

PlayerTab:CreateSlider({
    Name = "Car Acceleration Factor", -- Переименовано
    Range = {1, 10}, -- Min 1x (нормальное ускорение) до 10x
    Increment = 0.5,
    Suffix = "x",
    CurrentValue = 1.0,
    Flag = "CarSpeedFactorValue", -- Флаг можно оставить
    Callback = function(Value)
        carSpeedFactor = Value
        if carSpeedEnabled then -- Уведомляем, если уже включено
            Rayfield:Notify({Title = "Car Accelerator", Content = "Factor set to: " .. string.format("%.1f", carSpeedFactor) .. "x", Duration = 2, Image = 4483345998})
        end
    end
})

local WorldTab = Window:CreateTab("World", 7734068321)
local MapSection = WorldTab:CreateSection("Map")
WorldTab:CreateButton({
    Name = "Full Bright",
    Callback = function()
        if not _G.FullBrightExecuted then
            _G.FullBrightEnabled = false
            _G.NormalLightingSettings = {
                Brightness = Lighting.Brightness,
                ClockTime = Lighting.ClockTime,
                FogEnd = Lighting.FogEnd,
                GlobalShadows = Lighting.GlobalShadows,
                Ambient = Lighting.Ambient,
                OutdoorAmbient = Lighting.OutdoorAmbient,
                FogStart = Lighting.FogStart
            }
            _G.FullBrightExecuted = true
            
            -- Массив соединений для свойств Lighting
            _G.FullBrightConnections = {}
        end
        
        _G.FullBrightEnabled = not _G.FullBrightEnabled
        
        if _G.FullBrightEnabled then
            -- Отключаем существующие соединения
            if _G.FullBrightConnections then
                for _, connection in pairs(_G.FullBrightConnections) do
                    if connection then connection:Disconnect() end
                end
                _G.FullBrightConnections = {}
            end
            
            -- Функция для установки свойств полной яркости
            local function applyFullBrightSettings()
                -- Основные настройки освещения
                Lighting.Brightness = 2
                Lighting.GlobalShadows = false
                Lighting.Ambient = Color3.fromRGB(199, 199, 199)
                Lighting.OutdoorAmbient = Color3.fromRGB(199, 199, 199)
                
                -- Дополнительные настройки для лучшей видимости
                Lighting.ClockTime = 14 -- Полдень для максимальной освещенности
                Lighting.FogEnd = 786543 -- Практически убираем туман
                Lighting.FogStart = 0
                
                -- Отключаем эффекты затемнения
                for _, v in pairs(Lighting:GetChildren()) do
                    if v:IsA("BlurEffect") or v:IsA("ColorCorrectionEffect") or 
                       v:IsA("BloomEffect") or v:IsA("SunRaysEffect") then
                        v.Enabled = false
                    end
                end
            end
            
            -- Применяем настройки сразу
            applyFullBrightSettings()
            
            -- Создаем соединение с RenderStepped для постоянного обновления
            table.insert(_G.FullBrightConnections, RunService.RenderStepped:Connect(applyFullBrightSettings))
            
            -- Добавляем соединения с сигналами изменения свойств
            -- Эти соединения будут срабатывать мгновенно, когда игра пытается изменить значения
            local properties = {
                "Brightness", "GlobalShadows", "Ambient", "OutdoorAmbient", 
                "ClockTime", "FogEnd", "FogStart"
            }
            
            for _, property in ipairs(properties) do
                table.insert(_G.FullBrightConnections, 
                    Lighting:GetPropertyChangedSignal(property):Connect(function()
                        -- Если Full Bright включен и свойство не соответствует нашим настройкам,
                        -- мы немедленно восстанавливаем его
                        if _G.FullBrightEnabled then
                            if property == "Brightness" and Lighting.Brightness ~= 2 then
                                Lighting.Brightness = 2
                            elseif property == "GlobalShadows" and Lighting.GlobalShadows ~= false then
                                Lighting.GlobalShadows = false
                            elseif property == "Ambient" and Lighting.Ambient ~= Color3.fromRGB(199, 199, 199) then
                                Lighting.Ambient = Color3.fromRGB(199, 199, 199)
                            elseif property == "OutdoorAmbient" and Lighting.OutdoorAmbient ~= Color3.fromRGB(199, 199, 199) then
                                Lighting.OutdoorAmbient = Color3.fromRGB(199, 199, 199)
                            elseif property == "ClockTime" and Lighting.ClockTime ~= 14 then
                                Lighting.ClockTime = 14
                            elseif property == "FogEnd" and Lighting.FogEnd ~= 786543 then
                                Lighting.FogEnd = 786543
                            elseif property == "FogStart" and Lighting.FogStart ~= 0 then
                                Lighting.FogStart = 0
                            end
                        end
                    end)
                )
            end
            
            -- Добавляем соединение с Heartbeat как дополнительную страховку
            table.insert(_G.FullBrightConnections, RunService.Heartbeat:Connect(applyFullBrightSettings))
            
            -- Уведомляем пользователя
            Rayfield:Notify({
                Title = "Full Bright",
                Content = "Full Bright enabled with double protection against reset",
                Duration = 3,
                Image = 4483345998
            })
        else
            -- Отключаем все соединения
            if _G.FullBrightConnections then
                for _, connection in pairs(_G.FullBrightConnections) do
                    if connection then connection:Disconnect() end
                end
                _G.FullBrightConnections = {}
            end
            
            -- Восстанавливаем оригинальные настройки
            for setting, value in pairs(_G.NormalLightingSettings) do
                pcall(function() Lighting[setting] = value end)
            end
            
            -- Включаем обратно все эффекты
            for _, v in pairs(Lighting:GetChildren()) do
                if v:IsA("BlurEffect") or v:IsA("ColorCorrectionEffect") or 
                   v:IsA("BloomEffect") or v:IsA("SunRaysEffect") then
                    v.Enabled = true
                end
            end
            
            Rayfield:Notify({
                Title = "Full Bright",
                Content = "Full Bright disabled!",
                Duration = 3,
                Image = 4483345998
            })
        end
    end
})

WorldTab:CreateButton({
    Name = "Remove Foliage",
    Callback = function()
        local function cleanTrees()
            local treesFolder = Workspace:FindFirstChild("Trees")
            if treesFolder then treesFolder:Destroy() end
            local mapFolder = Workspace:FindFirstChild("map")
            if mapFolder then
                local mapTreesFolder = mapFolder:FindFirstChild("Trees")
                if mapTreesFolder then mapTreesFolder:Destroy() end
                local leafFolder = mapFolder:FindFirstChild("Leaf")
                if leafFolder then leafFolder:Destroy() end
                for _, model in ipairs(mapFolder:GetChildren()) do
                    if model:IsA("Model") and model.Name == "Tree" then
                        model:Destroy()
                    end
                end
            end
            for _, obj in ipairs(Workspace:GetChildren()) do
                if obj:IsA("Model") and obj.Name == "Tree" then
                    obj:Destroy()
                end
            end
        end
        cleanTrees()
    end
})

WorldTab:CreateButton({
    Name = "Remove Fog",
    Callback = function()
        for _, child in ipairs(Lighting:GetChildren()) do
            child:Destroy()
        end
    end
})

local OtherSection = WorldTab:CreateSection("Other")
WorldTab:CreateButton({
    Name = "Fps boost",
    Callback = function()
        local decalsyeeted = true
        sethiddenproperty(Lighting, "Technology", 2)
        local Terrain = Workspace.Terrain
        sethiddenproperty(Terrain, "Decoration", false)
        Terrain.WaterWaveSize     = 0
        Terrain.WaterWaveSpeed    = 0
        Terrain.WaterReflectance  = 0
        Terrain.WaterTransparency = 0
        Lighting.GlobalShadows    = false
        Lighting.FogEnd           = 9e9
        Lighting.Brightness       = 0
        settings().Rendering.QualityLevel = "Level01"
        for _, v in ipairs(Workspace:GetDescendants()) do
            if v:IsA("BasePart") and not v:IsA("MeshPart") then
                v.Material = "Plastic"
                v.Reflectance = 0
            elseif (v:IsA("Decal") or v:IsA("Texture")) and decalsyeeted then
                v.Transparency = 1
            elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
                v.Lifetime = NumberRange.new(0)
            elseif v:IsA("Explosion") then
                v.BlastPressure = 1
                v.BlastRadius   = 1
            elseif v:IsA("Fire") or v:IsA("SpotLight") or v:IsA("Smoke") or v:IsA("Sparkles") then
                v.Enabled = false
            elseif v:IsA("MeshPart") and decalsyeeted then
                v.Material = "Plastic"
                v.Reflectance = 0
                v.TextureID = 10385902758728957
            end
        end
    end
})

WorldTab:CreateToggle({
    Name = "RTX",
    CurrentValue = false,
    Flag = "RTXEnabled",
    Callback = function(Value)
        if Value then
            Lighting.Technology = Enum.Technology.Future
            Lighting.Ambient = Color3.fromRGB(25, 25, 25)
            Lighting.OutdoorAmbient = Color3.fromRGB(25, 25, 25)
            Lighting.ShadowSoftness = 0.1
            Lighting.EnvironmentDiffuseScale = 0.7
            Lighting.EnvironmentSpecularScale = 0.7
            Rayfield:Notify({
                Title = "RTX",
                Content = "RTX effects enabled",
                Duration = 3,
                Image = 4483345998
            })
        else
            Lighting.Technology = Enum.Technology.ShadowMap
            Lighting.Ambient = Color3.fromRGB(70, 70, 70)
            Lighting.OutdoorAmbient = Color3.fromRGB(0, 0, 0)
            Lighting.ShadowSoftness = 0
            Lighting.EnvironmentDiffuseScale = 1
            Lighting.EnvironmentSpecularScale = 0.425
            Rayfield:Notify({
                Title = "RTX",
                Content = "RTX effects disabled",
                Duration = 3,
                Image = 4483345998
            })
        end
    end
})

local MiscTab = Window:CreateTab("Misc", 4384401360)
local InfiniteYieldSection = MiscTab:CreateSection("Infinite Yield")
MiscTab:CreateButton({
    Name = "Infinite Yield",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
    end
})
local ServerSection = MiscTab:CreateSection("Server")
MiscTab:CreateButton({
    Name = "Reconnect",
    Callback = function()
        Rayfield:Notify({
            Title = "Reconnecting!",
            Content = "Preparing to reconnect...",
            Duration = 3,
            Image = 4483345998
        })
        task.wait(1)
        local player = Players.LocalPlayer
        local success, errorMsg = pcall(function()
            if game.JobId == "" then
                TeleportService:Teleport(game.PlaceId, player)
            else
                TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
            end
        end)
        if success then
            Rayfield:Notify({
                Title = "Reconnect",
                Content = "Reconnecting...",
                Duration = 3,
                Image = 4483345998
            })
        else
            task.wait(1)
            Rayfield:Notify({
                Title = "Error!",
                Content = "Failed to reconnect: " .. tostring(errorMsg),
                Duration = 5,
                Image = 4483345998
            })
            task.wait(1)
            Rayfield:Notify({
                Title = "Reconnect",
                Content = "Trying alternative method...",
                Duration = 3,
                Image = 4483345998
            })
            pcall(function()
                TeleportService:Teleport(game.PlaceId)
            end)
        end
    end
})

local modelName = "PyaterochkaPortal"
local model = Workspace:FindFirstChild(modelName)
if model then
    model:Destroy()
end
local mapFolder = Workspace:FindFirstChild("map")
if mapFolder then
    local texturesFolder = mapFolder:FindFirstChild("Textures_Overlay")
    if texturesFolder then texturesFolder:Destroy() end
end

local localPlayer = Players.LocalPlayer
Rayfield:Notify({
    Title = "Welcome, " .. localPlayer.Name .. "!",
    Content = "Join our discord or telegram for updates!",
    Duration = 10,
    Image = 4483345998
})


-- Альтернативная система ESP с использованием BillboardGui
local function CreateBillboardESP(part, folder)
    if not part then return nil end
    
    -- Создаем структуру для хранения элементов
    local espObject = {
        Part = part,
        Gui = nil,
        Label = nil
    }
    
    -- Создаем BillboardGui
    local success, result = pcall(function()
        local gui = Instance.new("BillboardGui")
        gui.Name = "DropESP_" .. part.Name
        gui.AlwaysOnTop = true
        gui.Size = UDim2.new(0, 200, 0, 50) -- Увеличиваем размер для лучшей видимости
        gui.StudsOffset = Vector3.new(0, 2, 0)
        gui.Adornee = part
        gui.MaxDistance = DropESP.MaxDistance
        
        -- Создаем текстовую метку (убираем рамку)
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 0.5, 0)
        label.Position = UDim2.new(0, 0, 0, 0)
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.fromRGB(255, 0, 0) -- Всегда красный текст
        label.TextStrokeTransparency = 0 -- Непрозрачный контур для лучшей видимости
        label.TextStrokeColor3 = Color3.new(0, 0, 0)
        label.TextSize = 18 -- Увеличиваем размер текста
        label.Font = Enum.Font.SourceSansBold
        label.Text = "Box[0m]"
        label.Parent = gui
        
        gui.Parent = folder
        
        return {
            Gui = gui,
            Label = label
        }
    end)
    
    if success then
        espObject.Gui = result.Gui
        espObject.Label = result.Label
        return espObject
    else
        Rayfield:Notify({
            Title = "ESP Error",
            Content = "Error creating BillboardGui: " .. tostring(result),
            Duration = 3,
            Image = 4483345998
        })
        return nil
    end
end

-- Функция обновления BillboardGui ESP
local function UpdateBillboardESP(espObject)
    if not espObject or not espObject.Part or not espObject.Part.Parent or not espObject.Gui then
        return false
    end
    
    local success = pcall(function()
        -- Обновляем видимость
        espObject.Gui.Enabled = DropESP.Enabled
        
        -- Получаем расстояние
        local player = Players.LocalPlayer
        local character = player and player.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
        
        if humanoidRootPart then
            local distance = (humanoidRootPart.Position - espObject.Part.Position).Magnitude
            espObject.Label.Text = string.format("drop[%dm]", math.floor(distance))
            
            -- Скрываем ESP, если расстояние слишком большое
            if distance > DropESP.MaxDistance then
                espObject.Gui.Enabled = false
            end
        end
    end)
    
    return success
end

-- Функция для удаления BillboardGui ESP
local function RemoveBillboardESP(espObject)
    if espObject and espObject.Gui then
        pcall(function()
            espObject.Gui:Destroy()
        end)
    end
end

-- Модифицируем DropESPManager для поддержки обоих типов ESP
function DropESPManager:CreateObject(dropPart)
    if not dropPart then return end
    
    if self.Objects[dropPart] then
        pcall(function() self:RemoveObject(dropPart) end)
    end
    
    if DropESP.UseDrawing then
        -- Используем существующую систему на основе Drawing
        local espObject = DropESPObject.new(dropPart)
        if espObject then
            self.Objects[dropPart] = {
                Type = "Drawing",
                Object = espObject
            }
        end
    else
        -- Используем систему на основе BillboardGui
        local folder = _G.DropESPFolder
        
        if not folder or not folder.Parent then
            folder = Instance.new("Folder")
            folder.Name = "DropESPFolder"
            
            -- Пытаемся разместить в CoreGui, но если не получится, размещаем в PlayerGui
            local success = pcall(function()
                folder.Parent = game:GetService("CoreGui")
            end)
            
            if not success then
                pcall(function()
                    folder.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
                end)
            end
            
            _G.DropESPFolder = folder
        end
        
        local espObject = CreateBillboardESP(dropPart, folder)
        if espObject then
            self.Objects[dropPart] = {
                Type = "BillboardGui",
                Object = espObject
            }
        end
    end
end

function DropESPManager:UpdateAll()
    -- Если папка с дропом не найдена, ищем ее
    if DropESP.Enabled and not DropESP.TargetFolder then
        DropESP.TargetFolder = FindDropFolder()
    end
    
    -- Обновляем существующие объекты
    for part, objData in pairs(self.Objects) do
        if part and part.Parent then
            if objData.Type == "Drawing" and objData.Object then
                objData.Object:Update()
            elseif objData.Type == "BillboardGui" and objData.Object then
                if not UpdateBillboardESP(objData.Object) then
                    self:RemoveObject(part)
                end
            end
        else
            self:RemoveObject(part)
        end
    end
    
    -- Поиск новых дропов, если ESP включен и папка найдена
    if DropESP.Enabled and DropESP.TargetFolder then
        local foundCount = 0
        
        -- Перебираем непосредственных потомков папки (без глубокого поиска)
        for _, model in pairs(DropESP.TargetFolder:GetChildren()) do
            -- Проверяем только объекты, которые являются моделями
            if model:IsA("Model") then
                local mainPart = GetModelMainPart(model)
                
                if mainPart and not self.Objects[mainPart] then
                    self:CreateObject(mainPart)
                    foundCount = foundCount + 1
                end
            end
        end
    end
end

function DropESPManager:RemoveObject(dropPart)
    if not dropPart or not self.Objects[dropPart] then return end
    
    local objData = self.Objects[dropPart]
    if objData.Type == "Drawing" and objData.Object then
        pcall(function() objData.Object:Remove() end)
    elseif objData.Type == "BillboardGui" and objData.Object then
        RemoveBillboardESP(objData.Object)
    end
    
    self.Objects[dropPart] = nil
end

function DropESPManager:ClearAllObjects()
    for part, _ in pairs(self.Objects) do
        self:RemoveObject(part)
    end
    
    -- Очищаем папку ESP
    if _G.DropESPFolder then
        pcall(function()
            _G.DropESPFolder:Destroy()
            _G.DropESPFolder = nil
        end)
    end
end

-- Ищем папку с дропом при загрузке скрипта
task.spawn(function()
    -- Небольшая задержка чтобы игра полностью загрузилась
    task.wait(1)
    
    -- Ищем папку только один раз при загрузке
    local success, result = pcall(function()
        return FindDropFolder()
    end)
    
    if success and result then
        DropESP.TargetFolder = result
    end
end)





