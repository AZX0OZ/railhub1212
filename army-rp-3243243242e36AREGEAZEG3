-- Add protection at the very beginning of the file
if not _G.RAILhub_KeyAuthorized then
    game:GetService("Players").LocalPlayer:Kick("Unauthorized access. Please use the official loader.")
    return
end

local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local weaponsFolder = workspace:FindFirstChild(player.Name)

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")

local Window = Rayfield:CreateWindow({
    Name = "RAILhub - Army Roblox RP",
    LoadingTitle = "RAILhub",
    LoadingSubtitle = "by SREE",
    Discord = {
        Enabled = true,
        Invite = "https://discord.gg/67UTqK8su5",
        RememberJoins = true
    }
})

local function smoothTeleport(targetPos)
    local player = Players.LocalPlayer
    local character = player and player.Character
    if not character then return end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    local originalWalkSpeed = humanoid.WalkSpeed
    local originalPlatformStand = humanoid.PlatformStand
    
    local startPos = hrp.Position
    local distance = (targetPos - startPos).Magnitude
    -- Увеличиваем скорость перемещения в 3 раза
    local teleportSpeed = 300  -- было 120, увеличили в 3 раза
    local duration = distance / teleportSpeed
    
    -- Изменяем смещение на +100 для полета над картой
    local aboveMapOffset = Vector3.new(0, 150, 0)
    local targetAbovePos = targetPos + aboveMapOffset
    
    -- Добавляем задержку для начала телепортации
    task.wait(0.15)  -- Уменьшили с 0.3 до 0.15
    
    humanoid.WalkSpeed = 0
    humanoid.PlatformStand = true
    
    -- Вычисляем все позиции заранее для создания плавной траектории
    local startAbovePos = startPos + aboveMapOffset
    
    -- Фиксируем начальную позицию на короткое время
    hrp.Anchored = true
    hrp.CFrame = CFrame.new(startPos)
    task.wait(0.2)  -- Уменьшили с 0.4 до 0.2
    hrp.Anchored = false
    
    -- Плавный подъем вверх (ускорили в 3 раза)
    local upwardTime = 0.33  -- было 1.0, уменьшили в 3 раза
    local upwardStart = tick()
    
    local upwardConnection
    upwardConnection = RunService.RenderStepped:Connect(function()
        local elapsed = tick() - upwardStart
        local progress = math.min(elapsed / upwardTime, 1)
        
        if progress < 1 then
            local currentHeight = startPos.Y + (aboveMapOffset.Y * progress)
            hrp.CFrame = CFrame.new(startPos.X, currentHeight, startPos.Z)
            hrp.Velocity = Vector3.new(0, 60, 0)  -- Было 20, увеличили в 3 раза
        else
            hrp.CFrame = CFrame.new(startAbovePos)
            hrp.Velocity = Vector3.new(0, 0, 0)
            if upwardConnection then upwardConnection:Disconnect() end
        end
    end)
    
    -- Дожидаемся завершения подъема
    task.wait(upwardTime + 0.05)  -- Уменьшили с 0.1 до 0.05
    
    local connection
    local startTime = tick()
    local isFlying = true
    local isDescending = false
    local hasReachedAbove = false
    
    -- Функция для плавного изменения скорости
    local function smoothVelocity(currentVel, targetVel, alpha)
        return currentVel:Lerp(targetVel, alpha)
    end
    
    -- Сохраняем текущую скорость для плавного изменения
    local currentVelocity = Vector3.new(0, 0, 0)
    
    connection = RunService.RenderStepped:Connect(function(deltaTime)
        if not character or not character:FindFirstChild("HumanoidRootPart") or not character.Parent then
            if connection then connection:Disconnect() end
            return
        end
        
        local currentTime = tick() - startTime
        local totalProgress = math.min(currentTime / duration, 1)
        
        -- Получаем текущую позицию для расчетов
        local currentPos = hrp.Position
        local distanceToTarget = (Vector3.new(targetPos.X, 0, targetPos.Z) - Vector3.new(currentPos.X, 0, currentPos.Z)).Magnitude
        
        -- Интерполяция для плавности движения
        local interpolationSpeed = 0.15  -- Увеличили с 0.1 до 0.15 для более быстрой реакции
        
        if isFlying and not isDescending then
            -- Проверяем, достигли ли мы точки над целью
            if distanceToTarget < 5 and not hasReachedAbove then
                -- Плавно снижаем скорость при достижении точки над целью
                hasReachedAbove = true
                
                for i = 1, 5 do  -- Уменьшили с 10 до 5 итераций
                    if not (character and character:FindFirstChild("HumanoidRootPart")) then break end
                    hrp.Velocity = hrp.Velocity * 0.7  -- Было 0.8, сделали более резким
                    task.wait(0.03)  -- Уменьшили с 0.05 до 0.03
                end
                
                -- Начинаем спуск после небольшой паузы
                task.wait(0.15)  -- Уменьшили с 0.3 до 0.15
                isDescending = true
            end
            
            if not hasReachedAbove then
                -- Горизонтальный полет к цели
                local direction = (Vector3.new(targetPos.X, 0, targetPos.Z) - Vector3.new(currentPos.X, 0, currentPos.Z)).Unit
                
                -- Замедляемся при приближении к цели
                local speedFactor = 1.0
                if distanceToTarget < 30 then  -- Уменьшили с 50 до 30
                    speedFactor = 0.5 + (distanceToTarget / 30) * 0.5  -- Адаптировали формулу
                end
                
                local targetVel = Vector3.new(direction.X * teleportSpeed * speedFactor, 0, direction.Z * teleportSpeed * speedFactor)
                currentVelocity = smoothVelocity(currentVelocity, targetVel, interpolationSpeed)
                hrp.Velocity = currentVelocity
                
                -- Поддерживаем постоянную высоту
                hrp.CFrame = CFrame.new(hrp.Position.X, startAbovePos.Y, hrp.Position.Z)
            end
        end
        
        if isDescending then
            -- Постепенно снижаем высоту (в 2 раза быстрее)
            local distanceToGround = currentPos.Y - targetPos.Y
            
            -- Плавно уменьшаем скорость снижения по мере приближения к земле (в 2 раза быстрее)
            local descentSpeed = math.min(60, distanceToGround * 0.6 + 6)  -- Было math.min(30, distanceToGround * 0.3 + 3)
            descentSpeed = math.max(10, descentSpeed) -- Минимальная скорость снижения (было 5)
            
            currentVelocity = Vector3.new(0, -descentSpeed, 0)
            hrp.Velocity = currentVelocity
            
            -- Фиксируем горизонтальное положение при снижении
            hrp.CFrame = CFrame.new(targetPos.X, hrp.Position.Y, targetPos.Z)
            
            -- Проверяем приземление
            if distanceToGround <= 3 then
                -- Плавное торможение перед приземлением
                for i = 1, 3 do  -- Уменьшили с 5 до 3 итераций
                    if not (character and character:FindFirstChild("HumanoidRootPart")) then break end
                    hrp.Velocity = hrp.Velocity * 0.5
                    task.wait(0.02)  -- Уменьшили с 0.03 до 0.02
                end
                
                -- Точное перемещение в конечную позицию
                hrp.Anchored = true
                hrp.CFrame = CFrame.new(targetPos)
                task.wait(0.1)  -- Уменьшили с 0.2 до 0.1
                
                -- Восстанавливаем настройки персонажа
                humanoid.WalkSpeed = originalWalkSpeed
                humanoid.PlatformStand = originalPlatformStand
                
                -- Плавное освобождение
                task.wait(0.1)  -- Уменьшили с 0.2 до 0.1
                hrp.Anchored = false
                hrp.Velocity = Vector3.new(0, 0, 0)
                
                -- Проверка на отбрасывание
                task.delay(0.2, function()  -- Уменьшили с 0.3 до 0.2
                    if character and character:FindFirstChild("HumanoidRootPart") then
                        local finalPos = character.HumanoidRootPart.Position
                        if (finalPos - targetPos).Magnitude > 3 then
                            character.HumanoidRootPart.CFrame = CFrame.new(targetPos)
                            character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
                        end
                    end
                end)
                
                if connection then connection:Disconnect() end
                isFlying = false
                return
            end
        end

        if totalProgress >= 1.0 then  
            hrp.Anchored = true
            hrp.CFrame = CFrame.new(targetPos)
            task.wait(0.1)  -- Уменьшили с 0.2 до 0.1
            
            humanoid.WalkSpeed = originalWalkSpeed
            humanoid.PlatformStand = originalPlatformStand
            
            hrp.Anchored = false
            hrp.Velocity = Vector3.new(0, 0, 0)
            
            if connection then connection:Disconnect() end
            isFlying = false
        end
    end)
end

local InfoTab = Window:CreateTab("Information", 7733960981)

InfoTab:CreateSection("Updates")
InfoTab:CreateLabel("Last update: 03.06.2025!")
InfoTab:CreateLabel("v 0.6.1.1!")

InfoTab:CreateButton({
    Name = "Discord Link",
    Callback = function()
        setclipboard("https://discord.gg/67UTqK8su5")
        
    end,
})

InfoTab:CreateButton({
    Name = "Telegram Link",
    Callback = function()
        setclipboard("https://t.me/+iAxwlFrbUsBiNzli")
        
    end,
})

local TeleportTab = Window:CreateTab("Teleport", 6035190846)
if TeleportTab then
    TeleportTab:CreateSection("Points of Interest")
end

local function CreateStyledTeleportButton(name, position)
    TeleportTab:CreateButton({
        Name = name,
        Info = "Click to teleport",
        Interact = "Teleport",
        CurrentValue = false,
        Flag = "Teleport_" .. name:gsub("%s+", "_"),
        Callback = function()
            smoothTeleport((typeof(position) == "CFrame") and position.Position or position)
        end
    })
end

local teleports = {
    {name = "Coffee Shop", pos = CFrame.new(1510.12548828125, 3, -50.033023834228516)},
    {name = "Police Post", pos = CFrame.new(1880.78711, 3.02372599, -79.1625366)},
    {name = "Gas Station", pos = CFrame.new(1611.48291, 3.68000031, 193.309387)},
    {name = "FSB Post", pos = CFrame.new(2594.14526, 2.96875048, -213.897064)},
    {name = "Checkpoint-1", pos = CFrame.new(1093.0481, 40.9999924, -59.7594757)},
    {name = "Checkpoint-2", pos = CFrame.new(1305.15637, 16.7970123, -66.1204681)},
    {name = "Village", pos = CFrame.new(2578.659912109375, 3.050001621246338, 48.234134674072266)},
    {name = "Parade Ground", pos = CFrame.new(33.97133255004883, 3.0999984741210938, -13.471328735351562)},
    {name = "Airborne", pos = CFrame.new(214.971634, 2.96874952, -79.2867432)},
    {name = "Military Unit Headquarters", pos = CFrame.new(-365.19281, 3.06999874, 67.8806)},
    {name = "Military Police", pos = CFrame.new(-397.532074, 3.0687499, 334.057129)},
    {name = "Canteen", pos = CFrame.new(86.8922577, 4.24000216, 235.584213)},
    {name = "Smugglers Base", pos = CFrame.new(665.766357, 26.5687485, -708.443604)},
    {name = "Mercenaries Base", pos = CFrame.new(826.204346, 2.96875048, -1223.91553)},
    {name = "Tower at CP-1", pos = CFrame.new(590.221, 140.583, 292.378)},
    {name = "Freddy Bear", pos = CFrame.new(3982.34155, 40.9999847, -73.8225555)}
}

for _, teleport in ipairs(teleports) do
    CreateStyledTeleportButton(teleport.name, teleport.pos)
end

CreateStyledTeleportButton("AFK Zone", CFrame.new(1196.45837, -7.10957336, -2100.12256))

local FarmTab = Window:CreateTab("Farm", 4483345737)
FarmTab:CreateSection("Drop")

local espDropEnabled    = false
local espDropConnection = nil
local ESPFolder         = nil
local dropCache         = {}
local updateInterval    = 0.5 
local lastUpdate        = 0

local DropESP = {
    Enabled = false,
    Names = true,
    Color = Color3.fromRGB(255, 0, 0),  
    Transparency = 1,
    MaxDistance = 100000,
    RainbowColor = false,
    TextSize = 13,
    TargetFolder = nil,
    UseDrawing = false, 
    Rainbow = {
        Speed = 1,
        Phase = 0
    }
}

local DropESPObject = {}
DropESPObject.__index = DropESPObject

local function GetRelativePosition(position)
    if not position then return Vector2.new(0, 0), false, 0 end
    
    local localPlayer = Players.LocalPlayer
    local character = localPlayer and localPlayer.Character
    local localRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    local success, result = pcall(function()
        local screenPos, onScreen = Workspace.CurrentCamera:WorldToViewportPoint(position)
        local dist = localRootPart and (localRootPart.Position - position).Magnitude or screenPos.Z
        return {screenPos, onScreen, dist} 
    end)
    
    if success and type(result) == "table" and #result == 3 then
        local screenPos = result[1]
        local onScreen = result[2]
        local dist = result[3]

        if type(screenPos) == "vector" and type(onScreen) == "boolean" and type(dist) == "number" then
            return Vector2.new(screenPos.X, screenPos.Y), onScreen, dist
        else 
            return Vector2.new(0, 0), false, 0
        end
    else
        return Vector2.new(0, 0), false, 0
    end
end

local function SafeCreateDrawing(drawingType, properties)
    if not Drawing then
        return nil
    end
    
    local success, drawing = pcall(function()
        local draw = Drawing.new(drawingType)
        for prop, value in pairs(properties) do
            draw[prop] = value
        end
        return draw
    end)
    
    if success then
        return drawing
    else
        return nil
        end
    end

function DropESPObject.new(dropPart)
    if not dropPart then return nil end
    
    local self = setmetatable({}, DropESPObject)
    self.Part = dropPart
    
    
    local nameLabel = SafeCreateDrawing("Text", {
        Text = "Box",
        Size = DropESP.TextSize,
        Center = true,
        Outline = true,
        OutlineColor = Color3.new(0, 0, 0),
        Color = DropESP.Color,
        Visible = false,
        Font = Drawing.Fonts and Drawing.Fonts.System or 1
    })
    
    if not nameLabel then
        return nil
    end
    
    self.Name = nameLabel
    
    return self
end


function DropESPObject:Update()
    
    local dropPos
    pcall(function()
        dropPos = self.Part.Position
    end)
    
    if not dropPos then
        self:Hide()
        return
    end
    
    
    local pos2D, onScreen, distance
    pcall(function()
        pos2D, onScreen, distance = GetRelativePosition(dropPos)
    end)
    
    
    if not pos2D or not onScreen or not distance or distance > DropESP.MaxDistance then
        self:Hide()
        return
    end
    
    
    local espColor = DropESP.Color
    
    if DropESP.RainbowColor then
        espColor = UpdateRainbowColor(DropESP.Rainbow.Phase)
        DropESP.Rainbow.Phase = (DropESP.Rainbow.Phase + DropESP.Rainbow.Speed) % 360
    end
    
    
    local size = math.clamp(40 - distance / 30, 15, 30)
    local boxSize = Vector2.new(size, size)
    local boxPosition = Vector2.new(pos2D.X - size/2, pos2D.Y - size/2)
    
    
    
    if DropESP.Names then
        pcall(function()
            self.Name.Text = string.format("Box[%d]", math.floor(distance))
            self.Name.Position = Vector2.new(pos2D.X, pos2D.Y - size/2 - 15)
            self.Name.Color = espColor
            self.Name.Visible = true
            self.Name.Transparency = DropESP.Transparency
        end)
    else
        pcall(function()
            self.Name.Visible = false
        end)
    end
end


function DropESPObject:Remove()
    pcall(function() self:Hide() end)
    pcall(function() if self.Name then self.Name:Remove() end end)
    
    self.Part = nil
    self.Name = nil
end
local DropESPManager = { Objects = {} }
function DropESPManager:CreateObject(dropPart)
    if not dropPart then return end
    if self.Objects[dropPart] then
        self:RemoveObject(dropPart)
    end
    local espObject = DropESPObject.new(dropPart)
    if espObject then
        self.Objects[dropPart] = espObject
    end
end

function DropESPManager:RemoveObject(dropPart)
    if self.Objects[dropPart] then
        self.Objects[dropPart]:Remove()
        self.Objects[dropPart] = nil
    end
end



local function FindDropFolder()
    if DropESP.TargetFolder then
        return DropESP.TargetFolder
    end
    
    local targetPos = Vector3.new(402.388428, 0.330908775, 203.474518)
    local closestDistance = 5
    local closestModel = nil
    
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if (obj:IsA("BasePart") or obj:IsA("Model")) then
            local objPos
            if obj:IsA("Model") and obj.PrimaryPart then
                objPos = obj.PrimaryPart.Position
            elseif obj:IsA("BasePart") then
                objPos = obj.Position
            else
                continue
            end
            
            local distance = (objPos - targetPos).Magnitude
            if distance < closestDistance then
                closestModel = obj
                closestDistance = distance
            end
        end
    end
    
    if closestModel then
        local folder = closestModel
        while folder and folder.Parent ~= Workspace do
            folder = folder.Parent
        end
        
        if folder and folder.Parent == Workspace then
            DropESP.TargetFolder = folder
            return folder
        end
    end
    
    local knownFolderNames = {"CaseDrops", "Cases", "Drops", "Supplies", "Loot"}
    for _, name in ipairs(knownFolderNames) do
        local folder = Workspace:FindFirstChild(name)
        if folder then
            DropESP.TargetFolder = folder
            return folder
        end
    end
    
    return nil
end

local function GetModelMainPart(model)
    if not model then return nil end
    
    if model:IsA("Model") then
        if model.PrimaryPart and model.PrimaryPart:IsA("BasePart") and model.PrimaryPart.Transparency < 0.9 then
            return model.PrimaryPart
        end
    
        for _, child in pairs(model:GetDescendants()) do
            if child:IsA("BasePart") and child.Transparency < 0.9 then
                return child
            end
        end
    elseif model:IsA("BasePart") and model.Transparency < 0.9 then
        return model
    end
    
    return nil
end

function DropESPManager:UpdateAll()
    if DropESP.Enabled and not DropESP.TargetFolder then
        DropESP.TargetFolder = FindDropFolder()
    end
    
    for part, objData in pairs(self.Objects) do
        if not part or not part.Parent then self:RemoveObject(part)
        elseif objData.Type == "Drawing" and objData.Object then objData.Object:Update()
        elseif objData.Type == "BillboardGui" and objData.Object then
            if not UpdateBillboardESP(objData.Object) then self:RemoveObject(part) end
        end
    end
    
    if DropESP.Enabled and DropESP.TargetFolder then
        for _, model in pairs(DropESP.TargetFolder:GetChildren()) do
            if model:IsA("Model") then
                local mainPart = GetModelMainPart(model)
                if mainPart and not self.Objects[mainPart] then
                    self:CreateObject(mainPart)
                end
            end
        end
    end
end
_G.TransparencyCheckConnection = nil
local function CheckTransparency()
    if not DropESP.TargetFolder or not DropESP.Enabled then return end
    for part, _ in pairs(DropESPManager.Objects) do
        if part and part.Parent and part:IsA("BasePart") and part.Transparency >= 0.9 then
            DropESPManager:RemoveObject(part)
        end
    end
    if DropESP.TargetFolder then
        for _, model in pairs(DropESP.TargetFolder:GetChildren()) do
            if model:IsA("Model") then
                local mainPart = GetModelMainPart(model)
                if mainPart and not DropESPManager.Objects[mainPart] then
                    DropESPManager:CreateObject(mainPart)
                end
            end
        end
    end
end

FarmTab:CreateToggle({
    Name = "ESP Boxes",
    CurrentValue = false,
    Flag = "DropESPEnabled",
    Callback = function(Value)
        DropESP.Enabled = Value
        _G.ESPNotifiedAfterFind = false
        
        if Value then
            
            if not _G.DropESPUpdateConnection then
                _G.DropESPUpdateConnection = RunService.Heartbeat:Connect(function()
                    if not DropESP.Enabled then return end
                    
                    local currentTime = tick()
                    if currentTime - lastUpdate < updateInterval then return end
                    lastUpdate = currentTime
                    
                    local success, err = pcall(function()
                        DropESPManager:UpdateAll()
                    end)
                end)
            end

            if not _G.TransparencyCheckConnection then
                _G.TransparencyCheckConnection = task.spawn(function()
                    while DropESP.Enabled do
                        pcall(CheckTransparency)
                        task.wait(1) 
                    end
                end)
            end
        else
            if _G.DropESPUpdateConnection then
                _G.DropESPUpdateConnection:Disconnect()
                _G.DropESPUpdateConnection = nil
            end

            if _G.TransparencyCheckConnection then
                task.cancel(_G.TransparencyCheckConnection)
                _G.TransparencyCheckConnection = nil
            end

            DropESPManager:ClearAllObjects()

        end
    end
})

-- Добавляем кнопку для телепортации к ближайшему ящику
FarmTab:CreateButton({
    Name = "Teleport to Box",
    Info = "Teleports you to the nearest box",
    Interact = "Teleport",
    Callback = function()
        -- Находим ближайший ящик
        local nearestBox = nil
        local nearestDistance = math.huge
        local character = Players.LocalPlayer.Character
        local rootPart = character and character:FindFirstChild("HumanoidRootPart")
        
        if not rootPart then return end
        
        -- Ищем папку с ящиками
        local dropFolder = FindDropFolder()
        if not dropFolder then return end
        
        -- Ищем ближайший ящик
        for _, model in pairs(dropFolder:GetChildren()) do
            if model:IsA("Model") then
                local mainPart = GetModelMainPart(model)
                if mainPart then
                    local distance = (rootPart.Position - mainPart.Position).Magnitude
                    if distance < nearestDistance then
                        nearestDistance = distance
                        nearestBox = mainPart
                    end
                end
            end
        end
        
        -- Телепортируемся к ближайшему ящику, если он найден
        if nearestBox then
            smoothTeleport(nearestBox.Position)
        end
    end
})


local PvpTab = Window:CreateTab("PvP", 4483345998)



PvpTab:CreateSection("Weapon Mod")
--------------------------------------------------------------------------------------------------------------------------
local Settings = {
    NoRecoilEnabled = false,
}

local function updateWeaponsFolder()
    weaponsFolder = workspace:FindFirstChild(player.Name)
    if not weaponsFolder then
    end
end

local function patchNoRecoil()
    if not weaponsFolder then return end
    
    local function searchAndPatch(obj)
        if type(obj) ~= "table" then return end
        
        local isRecoilSettings = false
        
        if rawget(obj, "Recoil") then isRecoilSettings = true end
        if rawget(obj, "CameraRecoilingEnabled") then isRecoilSettings = true end
        if rawget(obj, "RecoilSpeed") then isRecoilSettings = true end
        if rawget(obj, "AngleX_Min") then isRecoilSettings = true end
        
        if isRecoilSettings then
            pcall(function()
                if rawget(obj, "Accuracy") then rawset(obj, "Accuracy", 1e9) end
                if rawget(obj, "Recoil") then rawset(obj, "Recoil", 0) end
                if rawget(obj, "CameraRecoilingEnabled") then rawset(obj, "CameraRecoilingEnabled", false) end
                if rawget(obj, "RecoilSpeed") then rawset(obj, "RecoilSpeed", 0) end
                if rawget(obj, "RecoilDamper") then rawset(obj, "RecoilDamper", 1000) end
                if rawget(obj, "RecoilRedution") then rawset(obj, "RecoilRedution", 1) end
                if rawget(obj, "AngleX_Min") then rawset(obj, "AngleX_Min", 0) end
                if rawget(obj, "AngleX_Max") then rawset(obj, "AngleX_Max", 0) end
                if rawget(obj, "AngleY_Min") then rawset(obj, "AngleY_Min", 0) end
                if rawget(obj, "AngleY_Max") then rawset(obj, "AngleY_Max", 0) end
                if rawget(obj, "AngleZ_Min") then rawset(obj, "AngleZ_Min", 0) end
                if rawget(obj, "AngleZ_Max") then rawset(obj, "AngleZ_Max", 0) end
                if rawget(obj, "Spread") then rawset(obj, "Spread", 0) end
                if rawget(obj, "Bloom") then rawset(obj, "Bloom", 0) end
                if rawget(obj, "Spray") then rawset(obj, "Spray", 0) end
                if rawget(obj, "VisualRecoil") then rawset(obj, "VisualRecoil", 0) end
                if rawget(obj, "SpreadRedutionIS") then rawset(obj, "SpreadRedutionIS", 1) end
                if rawget(obj, "SpreadRedutionS") then rawset(obj, "SpreadRedutionS", 1) end
                if rawget(obj, "CrossExpansion") then rawset(obj, "CrossExpansion", 0) end
            end)
        end
    end
    
    for _, gun in pairs(weaponsFolder:GetChildren()) do
        local gunScript = gun:FindFirstChild("GunScript_Local")
        if gunScript then
            pcall(function()
                local settingModule = gun:FindFirstChild("Setting")
                if settingModule and settingModule:IsA("ModuleScript") then
                    local success, settings = pcall(require, settingModule)
                    if success and type(settings) == "table" then
                        searchAndPatch(settings)
                    end
                end
                
                for _, obj in pairs(getgc(true)) do
                    if type(obj) == "table" then
                        searchAndPatch(obj)
                    end
                end
                
                for _, obj in pairs(debug.getregistry()) do
                    if type(obj) == "table" then
                        searchAndPatch(obj)
                    end
                end
            end)
        end
    end
    
    local localPlayer = game:GetService("Players").LocalPlayer
    if localPlayer and localPlayer.Character then
        for _, tool in pairs(localPlayer.Character:GetChildren()) do
            if tool:IsA("Tool") then
                local gunScript = tool:FindFirstChild("GunScript_Local")
                if gunScript then
                    local env = getsenv(gunScript)
                    if env then
                        for name, func in pairs(env) do
                            if type(func) == "function" and (name:lower():find("recoil") or name == "RecoilCamera") then
                                local success = pcall(function()
                                    local originalFunction = func
                                    env[name] = function(...)
                                        return nil
                                    end
                                end)
                            end
                        end
                    end
                end
            end
        end
    end
end

PvpTab:CreateToggle({
    Name = "No Recoil",
    CurrentValue = false,
    Flag = "NoRecoilToggle",
    Callback = function(Value)
        Settings.NoRecoilEnabled = Value
        if Value then
            patchNoRecoil()
        end
    end
})
--[[
local AimbotSection = PvpTab:CreateSection("Tracers")

PvpTab:CreateToggle({
    Name = "Tracer",
    CurrentValue = false,
    Flag = "BulletTracersToggle",
    Callback = function(Value)
        Settings.BulletTracersEnabled = Value
        if not _G.TracerSettings then
            _G.TracerSettings = {
                enabled = Value,
                activeBulletTracers = {},
                bulletTracerLifetime = 1,
                bulletTracerWidth = 0.2,
                bulletTracerFadeoutPoint = 0.7,
                bulletTracerColor = Color3.fromRGB(255, 255, 255),
                bulletTracerSpeed = 5,
                bulletTracerTexture = "http://www.roblox.com/asset/?id=446111271",
                bulletTracerMaxDistance = 1300
            }
        else
            _G.TracerSettings.enabled = Value
        end
        
        if Value then
            enableBulletTracers()
        else
            clearAllBulletTracers()
            if _G.TracerConnection then
                _G.TracerConnection:Disconnect()
                _G.TracerConnection = nil
            end
        end
    end
})

PvpTab:CreateColorPicker({
    Name = "Tracer Color",
    Color = Color3.fromRGB(255, 255, 255),
    Flag = "TracerColor",
    Callback = function(Value)
        if _G.TracerSettings then
            _G.TracerSettings.bulletTracerColor = Value
        end
    end
})

PvpTab:CreateSlider({
    Name = "Tracer Soze",
    Range = {0.1, 0.5},
    Increment = 0.05,
    Suffix = "",
    CurrentValue = 0.2,
    Flag = "TracerWidth",
    Callback = function(Value)
        if _G.TracerSettings then
            _G.TracerSettings.bulletTracerWidth = Value
        end
    end
})

PvpTab:CreateSlider({
    Name = "Life Time",
    Range = {0.5, 3},
    Increment = 0.1,
    Suffix = "сек",
    CurrentValue = 1,
    Flag = "TracerLifetime",
    Callback = function(Value)
        if _G.TracerSettings then
            _G.TracerSettings.bulletTracerLifetime = Value
        end
    end
})

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and Settings.AutoFireEnabled and input.UserInputType == Enum.UserInputType.MouseButton1 then
        isFiring = true
        autoFire()
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if not gameProcessed and Settings.AutoFireEnabled and input.UserInputType == Enum.UserInputType.MouseButton1 then
        isFiring = false
    end
end)

local function onChildAdded(child)
    if (child:IsA("Model") or child:IsA("Tool")) then
        local gunScript = child:FindFirstChild("GunScript_Local")
        local settingModule = child:FindFirstChild("Setting")
        if gunScript and settingModule and settingModule:IsA("ModuleScript") then
            local success, settings = pcall(require, settingModule)
            if success and type(settings) == "table" then
                if Settings.OriginalFireRate[child.Name] == nil then
                    Settings.OriginalFireRate[child.Name] = settings.FireRate or settings.Delay or 0.3
                end
                if Settings.RapidFireEnabled then
                    settings.FireRate = Settings.FireRate
                    if settings.Delay ~= nil then
                        settings.Delay = Settings.FireRate
                    end
                end
            end
        end
        if Settings.NoRecoilEnabled then
            patchNoRecoil()
        end
        if Settings.InstantReloadEnabled then
            patchInstantReload()
        end
        if Settings.InstantHitEnabled then
            patchInstantHit()
        end
        if Settings.BulletTracersEnabled then
            enableBulletTracers()
        end
    end
end

if weaponsFolder then
    weaponsFolder.ChildAdded:Connect(onChildAdded)
end

player.CharacterAdded:Connect(function(character)
    task.wait(1) 
    updateWeaponsFolder()

    task.delay(1, function()
        if Settings.RapidFireEnabled then
            setFireRateAllGuns(Settings.FireRate)
        end
        if Settings.NoRecoilEnabled then
            patchNoRecoil()
        end
        if Settings.InstantReloadEnabled then
            patchInstantReload()
        end
        if Settings.InstantHitEnabled then
            patchInstantHit()
        end
        if Settings.BulletTracersEnabled then
            enableBulletTracers()
        end
    end)
end)

updateWeaponsFolder()
if Settings.RapidFireEnabled then
    setFireRateAllGuns(Settings.FireRate)
end
if Settings.NoRecoilEnabled then
    patchNoRecoil()
end
if Settings.InstantReloadEnabled then
    patchInstantReload()
end
if Settings.InstantHitEnabled then
    patchInstantHit()
end
if Settings.BulletTracersEnabled then
    enableBulletTracers()
end
]]
local AimbotSection = PvpTab:CreateSection("Aimbot")


local Aimbot = {
    Enabled = false,
    TeamCheck = true,
    ShowFOV = false,
    VisibilityCheck = false,
    FOVSize = 100,
    Smoothness = 0.5,
    PredictionAmount = 0,
    TargetPart = "Head",
    FOVColor = Color3.fromRGB(255, 255, 255),
    FOVTransparency = 1,
    HeadOffset = Vector3.new(0, 0, 0), 
    Keybind = nil,
    MouseButton = Enum.UserInputType.MouseButton2,
    Tracker = false,
    TrackerColor = Color3.fromRGB(255, 255, 255),
    TrackerThickness = 1.5,
    TrackerYOffset = 5  
}


local AimbotFOVCircle = Drawing.new("Circle")
AimbotFOVCircle.Thickness = 1.5
AimbotFOVCircle.NumSides = 36
AimbotFOVCircle.Radius = Aimbot.FOVSize
AimbotFOVCircle.Filled = false
AimbotFOVCircle.Visible = false
AimbotFOVCircle.Transparency = Aimbot.FOVTransparency
AimbotFOVCircle.Color = Aimbot.FOVColor

local AimbotTrackerLine = Drawing.new("Line")
AimbotTrackerLine.Thickness = 1.5
AimbotTrackerLine.Transparency = 1
AimbotTrackerLine.Visible = false
AimbotTrackerLine.Color = Color3.fromRGB(255, 255, 255)

if _G.TrackerUpdateConnection then
    _G.TrackerUpdateConnection:Disconnect()
    _G.TrackerUpdateConnection = nil
end

if AimbotTrackerLine then
    AimbotTrackerLine:Remove()
end

AimbotTrackerLine = Drawing.new("Line")
AimbotTrackerLine.Thickness = 1.5
AimbotTrackerLine.Transparency = 1
AimbotTrackerLine.Visible = false
AimbotTrackerLine.Color = Color3.fromRGB(255, 255, 255)

_G.TrackerUpdateConnection = RunService.RenderStepped:Connect(function()
    pcall(function()
        if not (Aimbot and Aimbot.Tracker) then
            AimbotTrackerLine.Visible = false
            return
        end
        local mousePos = UserInputService:GetMouseLocation()
        local closestPlayer = nil
        local minDistance = Aimbot.FOVSize or 100
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= Players.LocalPlayer then
                local character = player.Character
                if character and character:FindFirstChildOfClass("Humanoid") and character.Humanoid.Health > 0 then
                    local hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local pos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(hrp.Position)
                        if onScreen then
                            local screenPos = Vector2.new(pos.X, pos.Y)
                            local distance = (mousePos - screenPos).Magnitude
                            
                            if distance < minDistance then
                                minDistance = distance
                                closestPlayer = {
                                    screenPos = screenPos,
                                    player = player
                                }
                            end
                        end
                    end
                end
            end
        end
        
        -- Отрисовываем трекер
        if closestPlayer then
            AimbotTrackerLine.From = mousePos
            AimbotTrackerLine.To = closestPlayer.screenPos
            AimbotTrackerLine.Thickness = Aimbot.TrackerThickness or 1.5
            AimbotTrackerLine.Color = Aimbot.TrackerColor or Color3.fromRGB(255, 255, 255)
            AimbotTrackerLine.Visible = true
        else
            AimbotTrackerLine.Visible = false
        end
    end)
end)

RunService.RenderStepped:Connect(function()
    if AimbotFOVCircle and Aimbot.ShowFOV then
        AimbotFOVCircle.Position = UserInputService:GetMouseLocation()
        AimbotFOVCircle.Radius = Aimbot.FOVSize
        AimbotFOVCircle.Transparency = Aimbot.FOVTransparency
        AimbotFOVCircle.Color = Aimbot.FOVColor
        AimbotFOVCircle.Visible = Aimbot.ShowFOV
    else
        if AimbotFOVCircle then
            AimbotFOVCircle.Visible = false
        end
    end
end)


local target = nil
local aiming = false
local camera = Workspace.CurrentCamera


local function IsVisible(part, partDescendant)
    local character = Players.LocalPlayer.Character
    local origin = camera.CFrame.Position
    local direction = (part.Position - origin).Unit * 300
    local ray = Ray.new(origin, direction)
    local hit, position = Workspace:FindPartOnRayWithIgnoreList(ray, {character, camera})
    if hit and hit:IsDescendantOf(partDescendant) then
        return true
    end
    return false
end


local function GetClosestPlayer(ignoreFOV)
    -- Устанавливаем значение по умолчанию для ignoreFOV
    if ignoreFOV == nil then ignoreFOV = false end
    
    local closestPlayer = nil
    local shortestDistance = math.huge
    
    local mousePos
    pcall(function() mousePos = UserInputService:GetMouseLocation() end)
    if not mousePos then return nil end
    
    local localPlayer = Players.LocalPlayer
    if not localPlayer then return nil end
    
    -- Таблица для хранения всех потенциальных целей
    local potentialTargets = {}
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            
            if Aimbot.TeamCheck and player.Team == localPlayer.Team then continue end
            
            local character = player.Character
            if character and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0 then
                local targetPart = character:FindFirstChild(Aimbot.TargetPart)
                
                if targetPart then
                    
                    if Aimbot.VisibilityCheck then
                        if not IsVisible(targetPart, character) then continue end
                    end
                    
                    local pos, onScreen = camera:WorldToScreenPoint(targetPart.Position)
                    if onScreen then
                        local distanceFromCursor = (Vector2.new(mousePos.X, mousePos.Y) - Vector2.new(pos.X, pos.Y)).Magnitude
                        
                        -- Если ignoreFOV = true, то игнорируем проверку на FOVSize
                        if not ignoreFOV and distanceFromCursor > Aimbot.FOVSize then continue end
                        
                        -- Добавляем игрока в список потенциальных целей с информацией о расстоянии от курсора
                        table.insert(potentialTargets, {
                            player = player,
                            distanceFromCursor = distanceFromCursor
                        })
                    end
                end
            end
        end
    end
    
    -- Сортируем потенциальные цели по расстоянию от центра FOV (курсора)
    table.sort(potentialTargets, function(a, b)
        return a.distanceFromCursor < b.distanceFromCursor
    end)
    
    -- Возвращаем ближайшего к центру FOV игрока
    if #potentialTargets > 0 then
        closestPlayer = potentialTargets[1].player
    end
    
    return closestPlayer
end


local function AimAtTarget(target)
    if not (target and target.Character) then return end
    
    local targetPart
    pcall(function() targetPart = target.Character:FindFirstChild(Aimbot.TargetPart) end)
    if not targetPart then return end
    
    local targetPos
    pcall(function() targetPos = targetPart.Position end)
    if not targetPos then return end
    
    local velocity
    pcall(function() velocity = targetPart.Velocity end)
    if not velocity then velocity = Vector3.new(0, 0, 0) end
    
    targetPos = targetPos + (velocity * Aimbot.PredictionAmount)
    
    local aimPos = targetPos + Aimbot.HeadOffset
    
    local smoothness = 1 - Aimbot.Smoothness
    pcall(function()
        camera.CFrame = camera.CFrame:Lerp(CFrame.new(camera.CFrame.Position, aimPos), smoothness)
    end)
end


local aimLoop = nil

local function StartAimbot()
    if aimLoop then return end
    
    local success
    success, target = pcall(function() return GetClosestPlayer() end)
    if not success then target = nil end
    
    aiming = true
    
    aimLoop = RunService.RenderStepped:Connect(function()
        if not Aimbot.Enabled or not aiming then return end
        
        local success = pcall(function()
            target = GetClosestPlayer()
        end)
        
        if success and target then
            local targetPart
            pcall(function() 
                if target.Character then
                    targetPart = target.Character:FindFirstChild(Aimbot.TargetPart)
                end
            end)
            
            if targetPart then
                pcall(function() AimAtTarget(target) end)
                
                -- Трекер теперь обрабатывается в основном цикле RenderStepped
                -- для возможности отображения даже когда аимбот не активен
            else
                AimbotTrackerLine.Visible = false
            end
        else
            AimbotTrackerLine.Visible = false
        end
    end)
end

local function StopAimbot()
    aiming = false
    if aimLoop then
        aimLoop:Disconnect()
        aimLoop = nil
    end
    -- Удалено отключение трекера при остановке аимбота, 
    -- поскольку трекер теперь независим от аимбота
end


UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed then
        if Aimbot.MouseButton then
            
            if input.UserInputType == Aimbot.MouseButton then
                aiming = true
                StartAimbot()
            end
        elseif input.KeyCode == Aimbot.Keybind then
            aiming = true
            StartAimbot()
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if not gameProcessed then
        if Aimbot.MouseButton then
            
            if input.UserInputType == Aimbot.MouseButton then
                aiming = false
                StopAimbot()
            end
        elseif input.KeyCode == Aimbot.Keybind then
            aiming = false
            StopAimbot()
        end
    end
end)


PvpTab:CreateToggle({
    Name = "Enable Aimbot",
    CurrentValue = false,
    Flag = "AimbotEnabled",
    Callback = function(Value)
        Aimbot.Enabled = Value
        if not Value then
            StopAimbot()
        end
    end
})

PvpTab:CreateToggle({
    Name = "Team Check",
    CurrentValue = true,
    Flag = "AimbotTeamCheck",
    Callback = function(Value)
        Aimbot.TeamCheck = Value
    end
})

PvpTab:CreateToggle({
    Name = "Show FOV",
    CurrentValue = false,
    Flag = "AimbotShowFOV",
    Callback = function(Value)
        Aimbot.ShowFOV = Value
    end
})

PvpTab:CreateToggle({
    Name = "Show Tracker",
    CurrentValue = false,
    Flag = "AimbotTracker",
    Callback = function(Value)
        Aimbot.Tracker = Value
        if not Value then
            AimbotTrackerLine.Visible = false
        end
    end
})

PvpTab:CreateToggle({
    Name = "Visibility Check",
    CurrentValue = false,
    Flag = "AimbotVisibilityCheck",
    Callback = function(Value)
        Aimbot.VisibilityCheck = Value
    end
})

PvpTab:CreateSlider({
    Name = "FOV Size",
    Range = {5, 800},
    Increment = 5,
    Suffix = "px",
    CurrentValue = 100,
    Flag = "AimbotFOVSize",
    Callback = function(Value)
        Aimbot.FOVSize = Value
    end
})

PvpTab:CreateSlider({
    Name = "Smoothness",
    Range = {0, 1},
    Increment = 0.01,
    Suffix = "",
    CurrentValue = 0.5,
    Flag = "AimbotSmoothness",
    Callback = function(Value)
        Aimbot.Smoothness = Value
    end
})

PvpTab:CreateSlider({
    Name = "Prediction",
    Range = {0, 1},
    Increment = 0.01,
    Suffix = "",
    CurrentValue = 0,
    Flag = "AimbotPrediction",
    Callback = function(Value)
        Aimbot.PredictionAmount = Value
    end
})

PvpTab:CreateDropdown({
    Name = "Target Part",
    Options = {"Head", "HumanoidRootPart", "Torso",},
    CurrentOption = "Head",
    Flag = "AimbotTargetPart",
    Callback = function(Value)
        Aimbot.TargetPart = Value
    end
})

PvpTab:CreateDropdown({
    Name = "Aimbot Button",
    Options = {"M1", "M2", "E", "X"},
    CurrentOption = "M2",
    Flag = "AimbotButton",
    Callback = function(Value)
        
        Aimbot.Keybind = nil
        Aimbot.MouseButton = nil
        
        if Value == "E" then
            Aimbot.Keybind = Enum.KeyCode.E
        elseif Value == "X" then
            Aimbot.Keybind = Enum.KeyCode.X
        elseif Value == "M1" then
            Aimbot.MouseButton = Enum.UserInputType.MouseButton1
        elseif Value == "M2" then
            Aimbot.MouseButton = Enum.UserInputType.MouseButton2
        end 
    end
})

local ESPTab = Window:CreateTab("ESP", 7733774602)
local ESP = {
    Enabled     = false,
    Boxes       = false,
    BoxShift    = CFrame.new(0, -1.5, 0),
    BoxSize     = Vector3.new(4, 6, 0),
    Color       = Color3.fromRGB(255, 255, 255),
    HealthBars  = false,
    Names       = false,
    Distance    = false,
    Chams       = false,
    Skeletons   = false,
    Weapon      = false,
    LookAt      = false,
    TracerFrom  = "Bottom", 
    Tracers     = false,
    Transparency = 1,
    TeamDisplay = false,
    Font        = Drawing.Fonts.System,
    TextOutline = true,
    MaxDistance = 10000000,
    TeamCheck   = false,
    Players     = true,
    TeamColor   = true,
    ShowTeammates = true,
    RainbowColor = false,
    Rainbow = {
        Speed = 1,
        Phase = 0
    }
}
if not _G.RAILhubConnections then _G.RAILhubConnections = {} end
if not _G.RAILhubDrawings then _G.RAILhubDrawings = {} end
if not _G.RAILhubHighlights then _G.RAILhubHighlights = {} end

local function CreateDrawing(type, properties)
    local drawing = Drawing.new(type)
    for property, value in pairs(properties) do
        drawing[property] = value
    end
    table.insert(_G.RAILhubDrawings, drawing)
    return drawing
end

local function GetRelativePosition(position)
    if not position then return Vector2.new(0, 0), false, 0 end
    
    local localPlayer = Players.LocalPlayer
    local character = localPlayer and localPlayer.Character
    local localRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    local success, result = pcall(function()
        local screenPos, onScreen = Workspace.CurrentCamera:WorldToViewportPoint(position)
        local dist = localRootPart and (localRootPart.Position - position).Magnitude or screenPos.Z
        return {screenPos, onScreen, dist} 
    end)
    
    if success and type(result) == "table" and #result == 3 then
        local screenPos = result[1]
        local onScreen = result[2]
        local dist = result[3]

        
        if type(screenPos) == "vector" and type(onScreen) == "boolean" and type(dist) == "number" then
            return Vector2.new(screenPos.X, screenPos.Y), onScreen, dist
        else
            
            return Vector2.new(0, 0), false, 0
        end
    else
        return Vector2.new(0, 0), false, 0
    end
end

local function GetEquippedWeapon(character)
    local weapon = "Hands"
    if character then
        for _, obj in pairs(character:GetChildren()) do
            if obj:IsA("Tool") and obj:FindFirstChild("Handle") then
                weapon = obj.Name
                break
            end
        end
    end
    return weapon
end

local function IsLookingAtPlayer(watcher, target)
    local watchers = watcher:FindFirstChild("Head")
    local targets = target:FindFirstChild("Head")
    
    if not watchers or not targets then return false end
    
    local direction = (targets.Position - watchers.Position).Unit
    local lookVector = watchers.CFrame.LookVector
    
    local dot = direction:Dot(lookVector)
    
    return dot > 0.9
end

local function GetColorBasedOnTeam(player)
    if not ESP.TeamColor then return ESP.Color end
    
    if player.Team == nil then return ESP.Color end
    
    
    return player.Team.TeamColor.Color
end

local function UpdateRainbowColor(phase)
    local frequency = 2 * math.pi / 360
    local r = math.sin(frequency * phase + 0) * 127 + 128
    local g = math.sin(frequency * phase + 2 * math.pi / 3) * 127 + 128
    local b = math.sin(frequency * phase + 4 * math.pi / 3) * 127 + 128
    return Color3.fromRGB(r, g, b)
end

local ESPObject = {}
ESPObject.__index = ESPObject

function ESPObject.new(player)
    local self = setmetatable({}, ESPObject)
    self.Player = player
    
    self.Box = {
        Outline = CreateDrawing("Square", {Thickness = 3, Color = Color3.new(0, 0, 0), Transparency = 1, Filled = false, Visible = false}),
        Main    = CreateDrawing("Square", {Thickness = 1, Color = ESP.Color, Transparency = 1, Filled = false, Visible = false})
    }
    self.Healthbar = {
        Outline = CreateDrawing("Square", {Thickness = 3, Color = Color3.new(0, 0, 0), Transparency = 1, Filled = false, Visible = false}),
        Main    = CreateDrawing("Square", {Thickness = 1, Color = Color3.fromRGB(0, 255, 0), Transparency = 1, Filled = true, Visible = false})
    }
    self.Name     = CreateDrawing("Text", {Text = player.Name, Size = 13, Center = true, Outline = ESP.TextOutline, Color = ESP.Color, Visible = false, Font = Drawing.Fonts.System})
    self.Team     = CreateDrawing("Text", {Text = "", Size = 12, Center = true, Outline = ESP.TextOutline, Color = ESP.Color, Visible = false, Font = Drawing.Fonts.System})
    self.Distance = CreateDrawing("Text", {Size = 13, Center = true, Outline = ESP.TextOutline, Color = ESP.Color, Visible = false, Font = Drawing.Fonts.System})
    self.Weapon   = CreateDrawing("Text", {Size = 13, Center = true, Outline = ESP.TextOutline, Color = ESP.Color, Visible = false, Font = Drawing.Fonts.System})
    self.LookingAt = CreateDrawing("Text", {Text = "👁️", Size = 14, Center = true, Outline = false, Color = Color3.fromRGB(255, 0, 0), Visible = false, Font = Drawing.Fonts.System})
    self.Tracer   = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false})
    
    self.Skeleton = {
        Head_Torso = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        
        UpperTorso_LowerTorso = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        LowerTorso_LeftUpperLeg = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        LowerTorso_RightUpperLeg = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        UpperTorso_LeftUpperArm = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        UpperTorso_RightUpperArm = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        LeftUpperArm_LeftLowerArm = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        RightUpperArm_RightLowerArm = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        LeftLowerArm_LeftHand = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        RightLowerArm_RightHand = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        LeftUpperLeg_LeftLowerLeg = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        RightUpperLeg_RightLowerLeg = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        LeftLowerLeg_LeftFoot = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        RightLowerLeg_RightFoot = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        
        Torso_LeftArm = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        Torso_RightArm = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        Torso_LeftLeg = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false}),
        Torso_RightLeg = CreateDrawing("Line", {Thickness = 1, Color = ESP.Color, Transparency = 1, Visible = false})
    }
    
    self.Chams = nil
    self:CreateChams()
    
    return self
end

function ESPObject:CreateChams()
    if self.Chams then
        self.Chams:Destroy()
        self.Chams = nil
    end

    self.Chams = Instance.new("Highlight")
    self.Chams.FillColor = ESP.Color
    self.Chams.OutlineColor = ESP.Color
    self.Chams.FillTransparency = 0.5
    self.Chams.OutlineTransparency = 0
    self.Chams.Enabled = false
    self.Chams.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    
    local success, err = pcall(function()
        self.Chams.Parent = game.CoreGui
    end)
    
    if not success then
        self.Chams.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
    end
    
    table.insert(_G.RAILhubHighlights, self.Chams)
    
    if self.Player and self.Player.Character then
        self:UpdateChamsAdornee(self.Player.Character)
    end
    
    if self.CharacterAddedConnection then
        self.CharacterAddedConnection:Disconnect()
        self.CharacterAddedConnection = nil
    end
    
    self.CharacterAddedConnection = self.Player.CharacterAdded:Connect(function(char)
        task.wait(0.5) 
        self:UpdateChamsAdornee(char)
    end)
end

function ESPObject:UpdateChamsAdornee(character)
    if not self.Chams then 
        self:CreateChams()
        if not self.Chams then return end
    end
    
    pcall(function()
        self.Chams.Adornee = character
        
        if ESP.Enabled and ESP.Chams then
            self.Chams.Enabled = true
        end
    end)
end

function ESPObject:Update()
    if not ESP.Enabled then return self:Hide() end
    local character = self.Player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") or not character:FindFirstChild("Humanoid") then
        return self:Hide()
    end
    
    if ESP.TeamCheck then
        local localPlayer = Players.LocalPlayer
        if localPlayer.Team and self.Player.Team == localPlayer.Team and not ESP.ShowTeammates then
            return self:Hide()
        end
    end
    
    if not self.Chams then
        self:CreateChams()
    end
    
    if self.Chams and self.Chams.Adornee ~= character then
        self:UpdateChamsAdornee(character)
    end
    
    local humanoid = character.Humanoid
    local rootPart = character.HumanoidRootPart
    local head = character:FindFirstChild("Head")
    
    if not head then return self:Hide() end 

    local rootPos = rootPart.Position
    
    local headPos, onScreen, distance = GetRelativePosition(rootPos)

    if not onScreen or distance > ESP.MaxDistance then return self:Hide() end
    
    local camera = Workspace.CurrentCamera
    
    local Size = rootPart.Size.Y
    local realDist = (camera.CFrame.Position - rootPos).Magnitude
    local baseFOV = 70 
    local fovCompensation = math.tan(math.rad(baseFOV) / 2) / math.tan(math.rad(camera.FieldOfView) / 2)
    local fixedScaleFactor = (Size * camera.ViewportSize.Y) / (realDist * 2) * fovCompensation
    local w, h = 3 * fixedScaleFactor, 4.5 * fixedScaleFactor
    
    local boxPosition = Vector2.new(headPos.X - w / 2, headPos.Y - h / 2)
    local boxSize = Vector2.new(w, h)

          local espColor = ESP.Color
      
      if ESP.RainbowColor then
          espColor = UpdateRainbowColor(ESP.Rainbow.Phase)
          ESP.Rainbow.Phase = (ESP.Rainbow.Phase + ESP.Rainbow.Speed) % 360
      elseif ESP.TeamColor then
          espColor = GetColorBasedOnTeam(self.Player)
      end
    
    local transparency = ESP.Transparency

    if ESP.Boxes then
        self.Box.Outline.Size = boxSize
        self.Box.Outline.Position = boxPosition
        self.Box.Outline.Visible = true
        self.Box.Outline.Transparency = transparency
        
        self.Box.Main.Size = boxSize
        self.Box.Main.Position = boxPosition
        self.Box.Main.Color = espColor
        self.Box.Main.Visible = true
        self.Box.Main.Transparency = transparency
    else
        self.Box.Outline.Visible = false
        self.Box.Main.Visible = false
    end

    if ESP.Names then
        self.Name.Text = self.Player.Name
        
        self.Name.Position = Vector2.new(boxPosition.X + boxSize.X / 2, boxPosition.Y - 15)
        self.Name.Color = espColor
        self.Name.Visible = true
        self.Name.Transparency = transparency
    else
        self.Name.Visible = false
    end

    if ESP.Distance then
        self.Distance.Text = string.format("%d M", math.floor(distance))
        
        self.Distance.Position = Vector2.new(boxPosition.X + boxSize.X / 2, boxPosition.Y + boxSize.Y + 5)
        self.Distance.Color = espColor
        self.Distance.Visible = true
        self.Distance.Transparency = transparency
    else
        self.Distance.Visible = false
    end
    
    if ESP.Weapon then
        local weapon = GetEquippedWeapon(character)
        self.Weapon.Text = weapon
        
        local weaponPosY = boxPosition.Y + boxSize.Y + (ESP.Distance and 20 or 5)
        self.Weapon.Position = Vector2.new(boxPosition.X + boxSize.X / 2, weaponPosY)
        self.Weapon.Color = espColor
        self.Weapon.Visible = true
        self.Weapon.Transparency = transparency
    else
        self.Weapon.Visible = false
    end
    
    if ESP.Tracers then
        local tracerStart
        local camera = Workspace.CurrentCamera
        
        if ESP.TracerFrom == "Bottom" then
            tracerStart = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
        elseif ESP.TracerFrom == "Top" then
            tracerStart = Vector2.new(camera.ViewportSize.X / 2, 0)
        elseif ESP.TracerFrom == "Mouse" then
            local mousePos = UserInputService:GetMouseLocation()
            tracerStart = Vector2.new(mousePos.X, mousePos.Y)
        end
        
        self.Tracer.From = tracerStart
        self.Tracer.To = Vector2.new(boxPosition.X + boxSize.X / 2, boxPosition.Y + boxSize.Y)
        self.Tracer.Color = espColor
        self.Tracer.Visible = true
        self.Tracer.Transparency = transparency
    else
        self.Tracer.Visible = false
    end
    
    if ESP.LookAt then
        local localPlayer = Players.LocalPlayer
        local localCharacter = localPlayer.Character
        
        if localCharacter and localCharacter:FindFirstChild("Head") then
            local isLooking = IsLookingAtPlayer(character, localCharacter)
             
            self.LookingAt.Position = Vector2.new(boxPosition.X + boxSize.X / 2, boxPosition.Y - 30)
            self.LookingAt.Visible = isLooking
            self.LookingAt.Transparency = transparency
        else
            self.LookingAt.Visible = false
        end
    else
        self.LookingAt.Visible = false
    end

    if ESP.HealthBars then
        local healthBarWidth = 5 
        local healthBarHeight = boxSize.Y 
         
        local healthBarPos = Vector2.new(boxPosition.X - healthBarWidth - 3, boxPosition.Y)

        self.Healthbar.Outline.Size = Vector2.new(healthBarWidth, healthBarHeight)
        self.Healthbar.Outline.Position = healthBarPos
        self.Healthbar.Outline.Visible = true
        self.Healthbar.Outline.Transparency = transparency
        
        local healthScale = humanoid.Health / humanoid.MaxHealth
        
        local filledHeight = healthBarHeight * healthScale
        self.Healthbar.Main.Size = Vector2.new(healthBarWidth, filledHeight)
        self.Healthbar.Main.Position = Vector2.new(healthBarPos.X, healthBarPos.Y + (healthBarHeight - filledHeight))
        self.Healthbar.Main.Color = Color3.fromRGB(255 * (1 - healthScale), 255 * healthScale, 0)
        self.Healthbar.Main.Visible = true
        self.Healthbar.Main.Transparency = transparency
    else
        self.Healthbar.Outline.Visible = false
        self.Healthbar.Main.Visible = false
    end
    
    if ESP.Skeletons then
        local isR15 = character:FindFirstChild("UpperTorso") ~= nil
        
        local parts = {
            Head = character:FindFirstChild("Head"),
            HumanoidRootPart = character:FindFirstChild("HumanoidRootPart"), 
            
            UpperTorso = character:FindFirstChild("UpperTorso"),
            LowerTorso = character:FindFirstChild("LowerTorso"),
            LeftUpperArm = character:FindFirstChild("LeftUpperArm"),
            RightUpperArm = character:FindFirstChild("RightUpperArm"),
            LeftLowerArm = character:FindFirstChild("LeftLowerArm"),
            RightLowerArm = character:FindFirstChild("RightLowerArm"),
            LeftHand = character:FindFirstChild("LeftHand"),
            RightHand = character:FindFirstChild("RightHand"),
            LeftUpperLeg = character:FindFirstChild("LeftUpperLeg"),
            RightUpperLeg = character:FindFirstChild("RightUpperLeg"),
            LeftLowerLeg = character:FindFirstChild("LeftLowerLeg"),
            RightLowerLeg = character:FindFirstChild("RightLowerLeg"),
            LeftFoot = character:FindFirstChild("LeftFoot"),
            RightFoot = character:FindFirstChild("RightFoot"),
            
            Torso = character:FindFirstChild("Torso"),
            ["Left Arm"] = character:FindFirstChild("Left Arm"),
            ["Right Arm"] = character:FindFirstChild("Right Arm"),
            ["Left Leg"] = character:FindFirstChild("Left Leg"),
            ["Right Leg"] = character:FindFirstChild("Right Leg")
        }
        
        for _, line in pairs(self.Skeleton) do
            line.Visible = false
        end
        
        local function drawLine(line, part1, part2)
            if part1 and part2 then
                local pos1, visible1 = GetRelativePosition(part1.Position)
                local pos2, visible2 = GetRelativePosition(part2.Position)
                
                if visible1 and visible2 then
                    line.From = pos1
                    line.To = pos2
                    line.Color = espColor
                    line.Visible = true
                    line.Transparency = transparency
                end
            end
        end
        
        if parts.Head then
            if isR15 and parts.UpperTorso then
                drawLine(self.Skeleton.Head_Torso, parts.Head, parts.UpperTorso)
            elseif parts.Torso then
                drawLine(self.Skeleton.Head_Torso, parts.Head, parts.Torso)
            elseif parts.HumanoidRootPart then 
                 drawLine(self.Skeleton.Head_Torso, parts.Head, parts.HumanoidRootPart)
            end
        end
        
        if isR15 then
            if parts.UpperTorso and parts.LowerTorso then
                drawLine(self.Skeleton.UpperTorso_LowerTorso, parts.UpperTorso, parts.LowerTorso)
            end
            
            if parts.UpperTorso and parts.LeftUpperArm then
                drawLine(self.Skeleton.UpperTorso_LeftUpperArm, parts.UpperTorso, parts.LeftUpperArm)
            end
            
            if parts.UpperTorso and parts.RightUpperArm then
                drawLine(self.Skeleton.UpperTorso_RightUpperArm, parts.UpperTorso, parts.RightUpperArm)
            end
            
            if parts.LeftUpperArm and parts.LeftLowerArm then
                drawLine(self.Skeleton.LeftUpperArm_LeftLowerArm, parts.LeftUpperArm, parts.LeftLowerArm)
            end
            
            if parts.RightUpperArm and parts.RightLowerArm then
                drawLine(self.Skeleton.RightUpperArm_RightLowerArm, parts.RightUpperArm, parts.RightLowerArm)
            end
            
            if parts.LeftLowerArm and parts.LeftHand then
                drawLine(self.Skeleton.LeftLowerArm_LeftHand, parts.LeftLowerArm, parts.LeftHand)
            end
            
            if parts.RightLowerArm and parts.RightHand then
                drawLine(self.Skeleton.RightLowerArm_RightHand, parts.RightLowerArm, parts.RightHand)
            end
            
            if parts.LowerTorso and parts.LeftUpperLeg then
                drawLine(self.Skeleton.LowerTorso_LeftUpperLeg, parts.LowerTorso, parts.LeftUpperLeg)
            end
            
            if parts.LowerTorso and parts.RightUpperLeg then
                drawLine(self.Skeleton.LowerTorso_RightUpperLeg, parts.LowerTorso, parts.RightUpperLeg)
            end
            
            if parts.LeftUpperLeg and parts.LeftLowerLeg then
                drawLine(self.Skeleton.LeftUpperLeg_LeftLowerLeg, parts.LeftUpperLeg, parts.LeftLowerLeg)
            end
            
            if parts.RightUpperLeg and parts.RightLowerLeg then
                drawLine(self.Skeleton.RightUpperLeg_RightLowerLeg, parts.RightUpperLeg, parts.RightLowerLeg)
            end
            
            if parts.LeftLowerLeg and parts.LeftFoot then
                drawLine(self.Skeleton.LeftLowerLeg_LeftFoot, parts.LeftLowerLeg, parts.LeftFoot)
            end
            
            if parts.RightLowerLeg and parts.RightFoot then
                drawLine(self.Skeleton.RightLowerLeg_RightFoot, parts.RightLowerLeg, parts.RightFoot)
            end
        else
            if parts.Torso and parts["Left Arm"] then
                drawLine(self.Skeleton.Torso_LeftArm, parts.Torso, parts["Left Arm"])
            end
            
            if parts.Torso and parts["Right Arm"] then
                drawLine(self.Skeleton.Torso_RightArm, parts.Torso, parts["Right Arm"])
            end
            
            if parts.Torso and parts["Left Leg"] then
                drawLine(self.Skeleton.Torso_LeftLeg, parts.Torso, parts["Left Leg"])
            end
            
            if parts.Torso and parts["Right Leg"] then
                drawLine(self.Skeleton.Torso_RightLeg, parts.Torso, parts["Right Leg"])
            end
        end
    else
        for _, line in pairs(self.Skeleton) do
            line.Visible = false
        end
    end

    if ESP.Chams then
        pcall(function()
            if not self.Chams then
                self:CreateChams()
            end
            
            self.Chams.Adornee = character
            self.Chams.FillColor = espColor
            self.Chams.OutlineColor = espColor
            self.Chams.FillTransparency = math.min(0.9, 1 - transparency)
            self.Chams.OutlineTransparency = math.min(0.9, 1 - transparency)
            self.Chams.Enabled = true
        end)
    else
        if self.Chams then
            self.Chams.Enabled = false
        end
    end

    if ESP.TeamDisplay and self.Player.Team then
        local teamName = self.Player.Team.Name
        local teamColor = self.Player.Team.TeamColor.Color
        
        self.Team.Text = "[" .. teamName .. "]"
        
        local teamPosY = boxPosition.Y - (ESP.LookAt and 45 or 30)
        self.Team.Position = Vector2.new(boxPosition.X + boxSize.X / 2, teamPosY)
        self.Team.Color = teamColor
        self.Team.Visible = true
        self.Team.Transparency = transparency
    else
        self.Team.Visible = false
    end
end

function ESPObject:Hide()
    self.Box.Outline.Visible = false
    self.Box.Main.Visible = false
    self.Healthbar.Outline.Visible = false
    self.Healthbar.Main.Visible = false
    self.Name.Visible = false
    self.Team.Visible = false
    self.Distance.Visible = false
    self.Weapon.Visible = false
    self.LookingAt.Visible = false
    self.Tracer.Visible = false
    self.Chams.Enabled = false
    
    for _, line in pairs(self.Skeleton) do
        line.Visible = false
    end
end

function ESPObject:Remove()
    self:Hide()
    
    if self.CharacterAddedConnection then
        self.CharacterAddedConnection:Disconnect()
        self.CharacterAddedConnection = nil
    end
    if self.Box.Outline then self.Box.Outline:Remove() end
    if self.Box.Main then self.Box.Main:Remove() end
    if self.Healthbar.Outline then self.Healthbar.Outline:Remove() end
    if self.Healthbar.Main then self.Healthbar.Main:Remove() end
    if self.Name then self.Name:Remove() end
    if self.Team then self.Team:Remove() end
    if self.Distance then self.Distance:Remove() end
    if self.Weapon then self.Weapon:Remove() end
    if self.LookingAt then self.LookingAt:Remove() end
    if self.Tracer then self.Tracer:Remove() end
    for _, line in pairs(self.Skeleton) do
        if line then line:Remove() end
    end
    
    if self.Chams then self.Chams:Destroy() end
end

local ESPManager = { Objects = {} }
function ESPManager:CreateObject(player)
    if self.Objects[player] then
        self.Objects[player]:Remove()
    end
    self.Objects[player] = ESPObject.new(player)
end

function ESPManager:RemoveObject(player)
    if self.Objects[player] then
        self.Objects[player]:Remove()
        self.Objects[player] = nil
    end
end

function ESPManager:UpdateAll()
    for _, object in pairs(self.Objects) do
        object:Update()
        
        
        if ESP.Enabled and ESP.Chams and object.Player and object.Player.Character then
            if not object.Chams or not object.Chams.Enabled then
                object:CreateChams()
                object:UpdateChamsAdornee(object.Player.Character)
            end
        end
        
        if ESP.Enabled and ESP.Tracers and ESP.TracerFrom == "Mouse" and object.Tracer and object.Tracer.Visible then
            local mousePos = UserInputService:GetMouseLocation()
            object.Tracer.From = Vector2.new(mousePos.X, mousePos.Y)
        end
    end
end

for _, player in pairs(Players:GetPlayers()) do
    if player ~= Players.LocalPlayer then
        ESPManager:CreateObject(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    ESPManager:CreateObject(player)
end)

Players.PlayerRemoving:Connect(function(player)
    ESPManager:RemoveObject(player)
end)

local lastESPUpdateTime = tick() 
local espUpdateInterval = 0.03 
if _G.ESPUpdateConnection then 
    _G.ESPUpdateConnection:Disconnect()
    _G.ESPUpdateConnection = nil
end

_G.ESPUpdateConnection = RunService.RenderStepped:Connect(function()
    local currentTime = tick() 
    
    if currentTime - lastESPUpdateTime >= espUpdateInterval then
        
    ESPManager:UpdateAll()
        
        lastESPUpdateTime = currentTime
    end
end)

local GeneralSection = ESPTab:CreateSection("General Settings")

ESPTab:CreateToggle({
    Name = "Enable ESP",
    CurrentValue = false,
    Flag = "EnableESP",
    Callback = function(Value)
        ESP.Enabled = Value
        
        
    end
})

ESPTab:CreateToggle({
    Name = "Team Check",
    CurrentValue = false,
    Flag = "TeamCheck",
    Callback = function(Value)
        ESP.TeamCheck = Value
        
        
        if Value then
            ESP.ShowTeammates = false
        else
            ESP.ShowTeammates = true
        end
    end
})

ESPTab:CreateToggle({
    Name = "Team Color",
    CurrentValue = true,
    Flag = "TeamColor",
    Callback = function(Value)
        ESP.TeamColor = Value
    end
})

ESPTab:CreateColorPicker({
    Name = "ESP Color",
    Color = Color3.fromRGB(255, 255, 255),
    Flag = "ESPColor",
    Callback = function(Value)
        ESP.Color = Value
    end
})

ESPTab:CreateToggle({
    Name = "Rainbow Color",
    CurrentValue = false,
    Flag = "RainbowColor",
    Callback = function(Value)
        ESP.RainbowColor = Value
    end
})

ESPTab:CreateSlider({
    Name = "Rainbow Speed",
    Range = {0.01, 5},
    Increment = 0.01,
    Suffix = "x",
    CurrentValue = 1,
    Flag = "RainbowSpeed",
    Callback = function(Value)
        ESP.Rainbow.Speed = Value
    end
})

ESPTab:CreateSlider({
    Name = "Transparency",
    Range = {0, 1},
    Increment = 0.1,
    Suffix = "%",
    CurrentValue = 1,
    Flag = "Transparency",
    Callback = function(Value)
        ESP.Transparency = Value
    end
})

ESPTab:CreateSlider({
    Name = "Maximum Distance",
    Range = {100, 10000},
    Increment = 100,
    Suffix = "m",
    CurrentValue = 10000,
    Flag = "MaxDistance",
    Callback = function(Value)
        ESP.MaxDistance = Value
    end
})

local ElementsSection = ESPTab:CreateSection("ESP Elements")

ESPTab:CreateToggle({
    Name = "Boxes",
    CurrentValue = false,
    Flag = "Boxes",
    Callback = function(Value)
        ESP.Boxes = Value
    end
})

ESPTab:CreateToggle({
    Name = "Health",
    CurrentValue = false,
    Flag = "Health",
    Callback = function(Value)
        ESP.HealthBars = Value
    end
})

ESPTab:CreateToggle({
    Name = "Names",
    CurrentValue = false,
    Flag = "Names",
    Callback = function(Value)
        ESP.Names = Value
    end
})

ESPTab:CreateToggle({
    Name = "Teams",
    CurrentValue = false,
    Flag = "Teams",
    Callback = function(Value)
        ESP.TeamDisplay = Value
    end
})


ESPTab:CreateToggle({
    Name = "Distance",
    CurrentValue = false,
    Flag = "Distance",
    Callback = function(Value)
        ESP.Distance = Value
    end
})

ESPTab:CreateToggle({
    Name = "Chams",
    CurrentValue = false,
    Flag = "Chams",
    Callback = function(Value)
        ESP.Chams = Value
        if Value then 
            for _, object in pairs(ESPManager.Objects) do
                if object.Player then
                    object:CreateChams()
                    if object.Player.Character then
                        object:UpdateChamsAdornee(object.Player.Character)
                    end
                end
            end
        else
            
            for _, object in pairs(ESPManager.Objects) do
                if object.Chams then
                    object.Chams.Enabled = false
                end
            end
        end
    end
})


ESPTab:CreateToggle({
    Name = "Skeletons",
    CurrentValue = false,
    Flag = "Skeletons",
    Callback = function(Value)
        ESP.Skeletons = Value
    end
})

ESPTab:CreateToggle({
    Name = "Weapon",
    CurrentValue = false,
    Flag = "Weapon",
    Callback = function(Value)
        ESP.Weapon = Value
    end
})

ESPTab:CreateToggle({
    Name = "Tracers",
    CurrentValue = false,
    Flag = "Tracers",
    Callback = function(Value)
        ESP.Tracers = Value
        
        
        if Value then
            local camera = Workspace.CurrentCamera
            local tracerStart
            
            
            if ESP.TracerFrom == "Bottom" then
                tracerStart = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
            elseif ESP.TracerFrom == "Top" then
                tracerStart = Vector2.new(camera.ViewportSize.X / 2, 0)
            elseif ESP.TracerFrom == "Mouse" then
                local mousePos = UserInputService:GetMouseLocation()
                tracerStart = Vector2.new(mousePos.X, mousePos.Y)
            end
            
            
            for _, object in pairs(ESPManager.Objects) do
                if object.Tracer then
                    object.Tracer.From = tracerStart
                end
            end
            
            local originType = type(ESP.TracerFrom) == "string" and ESP.TracerFrom or "Default"
        end
    end
})

ESPTab:CreateDropdown({
    Name = "Tracer Origin",
    Options = {"Bottom", "Top", "Mouse"},
    CurrentOption = "Bottom",
    Flag = "TracerOrigin",
    Callback = function(Value)
        local originValue = ""
        if type(Value) == "table" then
            originValue = tostring(Value[1] or "Unknown")
        else
            originValue = tostring(Value)
        end
        
        if originValue == "Bottom" then
            ESP.TracerFrom = "Bottom"
        elseif originValue == "Top" then
            ESP.TracerFrom = "Top"
        elseif originValue == "Mouse" then
            ESP.TracerFrom = "Mouse"
        end
        
        
        for _, object in pairs(ESPManager.Objects) do
            if object.Tracer and object.Tracer.Visible and ESP.Tracers then
                local camera = Workspace.CurrentCamera
                local tracerStart
                
                if ESP.TracerFrom == "Bottom" then
                    tracerStart = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
                elseif ESP.TracerFrom == "Top" then
                    tracerStart = Vector2.new(camera.ViewportSize.X / 2, 0)
                elseif ESP.TracerFrom == "Mouse" then
                    local mousePos = UserInputService:GetMouseLocation()
                    tracerStart = Vector2.new(mousePos.X, mousePos.Y)
                end
                
                object.Tracer.From = tracerStart
            end
        end
    end,
})

ESPTab:CreateToggle({
    Name = "Text Outline",
    CurrentValue = true,
    Flag = "TextOutline",
    Callback = function(Value)
        ESP.TextOutline = Value
        for _, object in pairs(ESPManager.Objects) do
            if object.Name then object.Name.Outline = Value end
            if object.Distance then object.Distance.Outline = Value end
            if object.Weapon then object.Weapon.Outline = Value end
        end
    end
})

local PlayerTab = Window:CreateTab("Player", 6022668898)

local CameraSection = PlayerTab:CreateSection("Camera")
local savedFov   = 70
local defaultFov = Workspace.CurrentCamera.FieldOfView
local isAdjusting  = false

PlayerTab:CreateButton({
    Name = "Reset FOV",
    Callback = function()
        Workspace.CurrentCamera.FieldOfView = defaultFov
        savedFov = defaultFov
    end
})

PlayerTab:CreateSlider({
    Name = "FOV",
    Range = {10, 120},
    Increment = 1,
    Suffix = "FOV",
    CurrentValue = defaultFov,
    Flag = "FOVValue",
    Callback = function(Value)
        Workspace.CurrentCamera.FieldOfView = Value
        savedFov = Value
        isAdjusting = true
    end
})

PlayerTab:CreateButton({
    Name = "Infinite Zoom",
    Callback = function()
        Players.LocalPlayer.CameraMaxZoomDistance = 99999999
    end
})

local ResolutionSection = PlayerTab:CreateSection("Screen Stretching")

local resolutionEnabled = false
local resolutionValue = 0.65
local resolutionConnection = nil

local function setupResolutionConnection(enable)
    if enable then
        if not resolutionConnection then
            getgenv().Resolution = {
                [".gg/scripters"] = resolutionValue
            }
            
            resolutionConnection = game:GetService("RunService").RenderStepped:Connect(
                function()
                    local Camera = workspace.CurrentCamera
                    Camera.CFrame = Camera.CFrame * CFrame.new(0, 0, 0, 1, 0, 0, 0, getgenv().Resolution[".gg/scripters"], 0, 0, 0, 1)
                end
            )
            
            if getgenv().gg_scripters == nil then
                getgenv().gg_scripters = "Aori0001"
            end
        end
    else
        if resolutionConnection then
            resolutionConnection:Disconnect()
            resolutionConnection = nil
        end
    end
end

PlayerTab:CreateToggle({
    Name = "Screen Stretching",
    CurrentValue = false,
    Flag = "ResolutionEnabled",
    Callback = function(Value)
        resolutionEnabled = Value
        setupResolutionConnection(Value)
    end
})

PlayerTab:CreateSlider({
    Name = "Stretching Value",
    Range = {0.1, 1.2},
    Increment = 0.05,
    Suffix = "x",
    CurrentValue = 0.65,
    Flag = "ResolutionValue",
    Callback = function(Value)
        resolutionValue = Value
        if resolutionEnabled and getgenv().Resolution then
            getgenv().Resolution[".gg/scripters"] = Value
        end
    end
})

local ZoomSection = PlayerTab:CreateSection("Zoom-hack")
local zoomEnabled   = false
local zoomStrength  = 2
local isZooming     = false
local zoomFov       = 70

PlayerTab:CreateToggle({
    Name = "zoom on Z",
    CurrentValue = false,
    Flag = "ZoomEnabled",
    Callback = function(Value)
        zoomEnabled = Value
        if not Value and isZooming then
            Workspace.CurrentCamera.FieldOfView = savedFov
            isZooming = false
        end
    end
})

PlayerTab:CreateSlider({
    Name = "Zoom Strength",
    Range = {1.1, 10},
    Increment = 0.1,
    Suffix = "x",
    CurrentValue = 2,
    Flag = "ZoomStrength",
    Callback = function(Value)
        zoomStrength = Value
        if isZooming then
            Workspace.CurrentCamera.FieldOfView = zoomFov / zoomStrength
        end
    end
})

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and zoomEnabled and input.KeyCode == Enum.KeyCode.Z then
        zoomFov = Workspace.CurrentCamera.FieldOfView
        Workspace.CurrentCamera.FieldOfView = zoomFov / zoomStrength
        isZooming = true
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if not gameProcessed and zoomEnabled and input.KeyCode == Enum.KeyCode.Z and isZooming then
        Workspace.CurrentCamera.FieldOfView = savedFov
        isZooming = false
    end
end)

PlayerTab:CreateButton({
    Name = "free cam (shift + p)",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/Rollimonster/Roblox-FreeCam-Script/refs/heads/main/Roblox-FreeCam-Script'))()
    end
})

local MovementSection = PlayerTab:CreateSection("Movement Settings")
PlayerTab:CreateSlider({
    Name = "Movement Speed",
    Range = {0, 200},
    Increment = 0.5,
    Suffix = "Speed",
    CurrentValue = 50,
    Flag = "SpeedValue",
    Callback = function(Value)
        getgenv().Speed = Value
    end
})

local tpWalkConnection = nil
getgenv().TpWalking = false
getgenv().Speed = 50 
local originalPlatformStandState = nil
local originalWalkSpeed = 16 

local function actualTeleportWalkingLogic(delta) 
    local player = Players.LocalPlayer
    local character = player and player.Character
    if not (getgenv().TpWalking and character and character.Parent) then
        return
    end

    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")

    if not (humanoid and humanoid.Parent and rootPart and rootPart.Parent) then
        return
    end
    
    local camera = Workspace.CurrentCamera
    local moveInputDirection = Vector3.new(0, 0, 0)

    local camLook = camera.CFrame.LookVector
    local camRight = camera.CFrame.RightVector

    local flatLook = Vector3.new(camLook.X, 0, camLook.Z)
    if flatLook.Magnitude > 0.001 then flatLook = flatLook.Unit end
    
    local flatRight = Vector3.new(camRight.X, 0, camRight.Z)
    if flatRight.Magnitude > 0.001 then flatRight = flatRight.Unit end

    if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveInputDirection = moveInputDirection + flatLook end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveInputDirection = moveInputDirection - flatLook end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveInputDirection = moveInputDirection - flatRight end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveInputDirection = moveInputDirection + flatRight end

    local currentSpeed = getgenv().Speed
    
    if moveInputDirection.Magnitude > 0.001 then
        moveInputDirection = moveInputDirection.Unit
        rootPart.Velocity = Vector3.new(moveInputDirection.X * currentSpeed, rootPart.Velocity.Y, moveInputDirection.Z * currentSpeed)
    else
        rootPart.Velocity = Vector3.new(0, rootPart.Velocity.Y, 0) -- Останавливаем горизонтальное движение при отсутствии ввода
    end
end

local function manageTpWalkConnection(enable)
    local player = Players.LocalPlayer
    local character = player and player.Character
    local humanoid = character and character:FindFirstChild("Humanoid")

    if enable then
        if not tpWalkConnection then
            if humanoid then 
                originalPlatformStandState = humanoid.PlatformStand 
                originalWalkSpeed = humanoid.WalkSpeed
                humanoid.PlatformStand = false -- Убедимся, что PlatformStand выключен для нормальной гравитации
                humanoid.WalkSpeed = 0 -- Отключаем стандартное движение
            else
                originalPlatformStandState = false 
                originalWalkSpeed = 16
            end
            tpWalkConnection = RunService.RenderStepped:Connect(actualTeleportWalkingLogic)
        end
    else
        if tpWalkConnection then
            tpWalkConnection:Disconnect()
            tpWalkConnection = nil
            if humanoid then
                if originalPlatformStandState ~= nil then
                    humanoid.PlatformStand = originalPlatformStandState
                else
                    humanoid.PlatformStand = false 
                end
                humanoid.WalkSpeed = originalWalkSpeed
                
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    rootPart.Velocity = Vector3.new(0, rootPart.Velocity.Y, 0)
                end
            end
            originalPlatformStandState = nil
        end
    end
end

PlayerTab:CreateToggle({
    Name = "Enable", 
    CurrentValue = false,
    Flag = "SpeedEnabled",
    Callback = function(Value)
        getgenv().TpWalking = Value
        manageTpWalkConnection(Value)
    end
})

local function onCharacterAdded(newCharacter)
    if getgenv().TpWalking then
        manageTpWalkConnection(false) 
        local newHumanoid = newCharacter:WaitForChild("Humanoid", 5)
        if newHumanoid then
             manageTpWalkConnection(true)
        end
    end
end

Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
if Players.LocalPlayer.Character then
    onCharacterAdded(Players.LocalPlayer.Character)
end


-- Новые переменные для Instant Run
local instantRunEnabled = false
local instantRunSpeed = 20
local originalRunAnimation = nil
local instantRunConnection = nil
local lastMoveDirectionMagnitude = 0

local function manageInstantRunConnection(enable)
    local player = Players.LocalPlayer
    local character = player and player.Character
    local humanoid = character and character:FindFirstChild("Humanoid")
    local animateScript = character and character:FindFirstChild("Animate")
    local runAnim = animateScript and animateScript:FindFirstChild("run") and animateScript.run:FindFirstChild("RunAnim")

    if enable then
        if not instantRunConnection then
            if humanoid then
                originalWalkSpeed = humanoid.WalkSpeed -- Сохраняем текущую скорость перед установкой 20
                humanoid.WalkSpeed = instantRunSpeed
            end
            
            -- Сохраняем оригинальную анимацию бега при первом включении
            if runAnim and not originalRunAnimation then
                originalRunAnimation = runAnim.AnimationId
            end

            instantRunConnection = RunService.RenderStepped:Connect(function()
                if not instantRunEnabled then return end
                
                local currentHumanoid = player.Character and player.Character:FindFirstChild("Humanoid")
                local currentRunAnim = player.Character and player.Character:FindFirstChild("Animate") and player.Character.Animate:FindFirstChild("run") and player.Character.Animate.run:FindFirstChild("RunAnim")

                if currentHumanoid then
                     -- Поддерживаем скорость 20, если она изменилась
                    if currentHumanoid.WalkSpeed ~= instantRunSpeed then
                        currentHumanoid.WalkSpeed = instantRunSpeed
                    end

                    local moveMagnitude = currentHumanoid.MoveDirection.Magnitude

                    if currentRunAnim then
                        if moveMagnitude > 0.001 and currentRunAnim.AnimationId ~= "rbxassetid://180426354" then
                            currentRunAnim.AnimationId = "rbxassetid://180426354"
                        elseif moveMagnitude <= 0.001 and originalRunAnimation and currentRunAnim.AnimationId ~= originalRunAnimation then
                             currentRunAnim.AnimationId = originalRunAnimation
                        end
                    end
                    lastMoveDirectionMagnitude = moveMagnitude
                end
            end)
        end
    else
        if instantRunConnection then
            instantRunConnection:Disconnect()
            instantRunConnection = nil
            if humanoid then
                humanoid.WalkSpeed = originalWalkSpeed -- Восстанавливаем оригинальную скорость
            end
            -- Восстанавливаем оригинальную анимацию бега при выключении тумблера
            if runAnim and originalRunAnimation then
                 runAnim.AnimationId = originalRunAnimation
            end
        end
         lastMoveDirectionMagnitude = 0
    end
end

-- Добавляем тумблер Instant Run
PlayerTab:CreateToggle({
    Name = "Instant Run",
    CurrentValue = false,
    Flag = "InstantRunEnabled",
    Callback = function(Value)
        instantRunEnabled = Value
        manageInstantRunConnection(Value)
    end
})

local FlightSection = PlayerTab:CreateSection("Flight")
local Flying = false
local FlightSpeed = 50   
local VerticalSpeed = 50 
local flyConnection
local camera = Workspace.CurrentCamera
local baseY 

local function startFlight()
    local player = Players.LocalPlayer
    local character = player and player.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not hrp or not humanoid then return end

    
    local isInVehicle = humanoid.SeatPart and humanoid.SeatPart:IsA("VehicleSeat")
    local vehiclePart = nil
    
    if isInVehicle then
        
        local vehicleSeat = humanoid.SeatPart
        vehiclePart = vehicleSeat 

        
        if vehicleSeat.Parent and vehicleSeat.Parent:IsA("Model") then
            local vehicleModel = vehicleSeat.Parent
            
            
            vehiclePart = vehicleModel.PrimaryPart or 
                          vehicleModel:FindFirstChild("Root") or 
                          vehicleModel:FindFirstChild("Body") or 
                          vehicleModel:FindFirstChild("Main") or
                          vehiclePart
            
            
            if not vehiclePart or not vehiclePart:IsA("BasePart") then
                for _, part in pairs(vehicleModel:GetDescendants()) do
                    if part:IsA("BasePart") and part ~= vehicleSeat then
                        vehiclePart = part
                        break
                    end
                end
            end
            
            
            if not vehiclePart:IsA("BasePart") then
                
                local playerCar = workspace:FindFirstChild(player.Name .. "sCar")
                if playerCar and playerCar:IsA("Model") then
                    vehiclePart = playerCar.PrimaryPart or 
                                  playerCar:FindFirstChild("Body") or 
                                  playerCar:FindFirstChild("Root") or
                                  playerCar:FindFirstChild("DriveSeat")
                    
                    if not vehiclePart or not vehiclePart:IsA("BasePart") then
                        for _, part in pairs(playerCar:GetDescendants()) do
                            if part:IsA("BasePart") then
                                vehiclePart = part
                                break
                            end
                        end
                    end
                end
            end
        end
        
        
        if not vehiclePart or not vehiclePart:IsA("BasePart") then
            vehiclePart = vehicleSeat
        end
    end
    
    humanoid.PlatformStand = not isInVehicle 
    baseY = hrp.Position.Y

    flyConnection = RunService.RenderStepped:Connect(function(delta)
        local moveDir = Vector3.new(0, 0, 0)
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            moveDir = moveDir + camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            moveDir = moveDir - camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            moveDir = moveDir - camera.CFrame.RightVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            moveDir = moveDir + camera.CFrame.RightVector
        end
        
        
        if moveDir.Magnitude > 0 then
            
            if isInVehicle then
                moveDir = Vector3.new(moveDir.X, 0, moveDir.Z).Unit
            else
                moveDir = moveDir.Unit
            end
        end

        local speedMultiplier = 1
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            speedMultiplier = 2
        end

        local verticalInput = 0
        if UserInputService:IsKeyDown(Enum.KeyCode.E) then
            verticalInput = VerticalSpeed
        elseif UserInputService:IsKeyDown(Enum.KeyCode.Q) then
            verticalInput = -VerticalSpeed
        end

        local pos
        if isInVehicle and vehiclePart then
            
            pos = vehiclePart.Position
        else
            
            pos = hrp.Position
        end
        
        local horizontalOffset = moveDir * FlightSpeed * speedMultiplier * delta
        
        local newX = pos.X + horizontalOffset.X
        local newZ = pos.Z + horizontalOffset.Z
        local newY
        if verticalInput ~= 0 then
            newY = pos.Y + verticalInput * speedMultiplier * delta
            baseY = newY 
        else
            newY = baseY 
        end

        local newPos = CFrame.new(newX, newY, newZ)
        
        if isInVehicle and vehiclePart then
            
            pcall(function()
                
                local lookAtDirection = moveDir
                if lookAtDirection.Magnitude > 0 then
                    
                    local vehicleHeight = vehiclePart.Position.Y
                    local targetPoint = vehiclePart.Position + lookAtDirection * 10
                    targetPoint = Vector3.new(targetPoint.X, vehicleHeight, targetPoint.Z)
                    
                    
                    local newCFrame = CFrame.lookAt(newPos.Position, targetPoint)
                    
                    
                    local currentCFrame = vehiclePart.CFrame
                    local blendAlpha = 0.1 
                    
                    
                    local _, currentRY, _ = currentCFrame:ToOrientation()
                    local targetX, targetY, targetZ = newCFrame:ToOrientation()
                    
                    
                    local adjustedCFrame = CFrame.new(newPos.Position) * CFrame.Angles(0, targetY, 0)
                    
                    
                    vehiclePart.AssemblyLinearVelocity = (newPos.Position - vehiclePart.Position) / delta
                    
                    vehiclePart.CFrame = currentCFrame:Lerp(adjustedCFrame, blendAlpha)
                    
                    vehiclePart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                else
                    
                    vehiclePart.AssemblyLinearVelocity = (newPos.Position - vehiclePart.Position) / delta
                    vehiclePart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end
            end)
        else
            
            hrp.CFrame = newPos
            hrp.Velocity = Vector3.new(0, 0, 0)
            hrp.RotVelocity = Vector3.new(0, 0, 0)
        end
    end)
end

local function stopFlight()
    local player = Players.LocalPlayer
    local character = player and player.Character
    if character then
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            
            local isInVehicle = humanoid.SeatPart and humanoid.SeatPart:IsA("VehicleSeat")
            
            if not isInVehicle then
                humanoid.PlatformStand = false
            end
            
            
            if isInVehicle then
                local vehicleSeat = humanoid.SeatPart
                local vehiclePart = nil
                
                
                if vehicleSeat.Parent and vehicleSeat.Parent:IsA("Model") then
                    local vehicleModel = vehicleSeat.Parent
                    
                    
                    vehiclePart = vehicleModel.PrimaryPart or 
                                  vehicleModel:FindFirstChild("Root") or 
                                  vehicleModel:FindFirstChild("Body") or 
                                  vehicleModel:FindFirstChild("Main") or
                                  vehicleSeat
                    
                    
                    if not vehiclePart or not vehiclePart:IsA("BasePart") then
                        for _, part in pairs(vehicleModel:GetDescendants()) do
                            if part:IsA("BasePart") and part ~= vehicleSeat then
                                vehiclePart = part
                                break
                            end
                        end
                    end
                    
                    
                    if not vehiclePart:IsA("BasePart") then
                        
                        local playerCar = workspace:FindFirstChild(player.Name .. "sCar")
                        if playerCar and playerCar:IsA("Model") then
                            vehiclePart = playerCar.PrimaryPart or 
                                          playerCar:FindFirstChild("Body") or 
                                          playerCar:FindFirstChild("Root") or
                                          playerCar:FindFirstChild("DriveSeat")
                            
                            if not vehiclePart or not vehiclePart:IsA("BasePart") then
                                for _, part in pairs(playerCar:GetDescendants()) do
                                    if part:IsA("BasePart") then
                                        vehiclePart = part
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
                
                
                if not vehiclePart or not vehiclePart:IsA("BasePart") then
                    vehiclePart = vehicleSeat
                end
                
                
                if vehiclePart and vehiclePart:IsA("BasePart") then
                    pcall(function()
                        vehiclePart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        vehiclePart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    end)
                end
            end
        end
    end
    if flyConnection then
        flyConnection:Disconnect()
        flyConnection = nil
    end
end

PlayerTab:CreateToggle({
    Name = "Flight",
    CurrentValue = false,
    Flag = "FlightEnabled",
    Callback = function(Value)
        Flying = Value 
        if Value then 
            startFlight() 
        else
            stopFlight()
        end
    end
})

PlayerTab:CreateSlider({
    Name = "Flight Speed",
    Range = {0, 70},
    Increment = 1,
    Suffix = " speed",
    CurrentValue = FlightSpeed,
    Flag = "FlightSpeed",
    Callback = function(Value)
        FlightSpeed = Value
    end
})

PlayerTab:CreateSlider({
    Name = "Vertical Speed",
    Range = {0, 250},
    Increment = 1,
    Suffix = " speed",
    CurrentValue = VerticalSpeed,
    Flag = "FlightVerticalSpeed",
    Callback = function(Value)
        VerticalSpeed = Value
    end
})

local JumpsSection = PlayerTab:CreateSection("Jumps Settings")

PlayerTab:CreateToggle({
    Name = "Infinite Jumps",
    CurrentValue = false,
    Flag = "InfiniteJump",
    Callback = function(Value)
        local Player = Players.LocalPlayer
        local UIS = UserInputService
        _G.JumpHeight = 50
        _G.IsJumpEnabled = Value
        UIS.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space then
                local character = Player.Character
                if _G.IsJumpEnabled and character and character:FindFirstChild("Humanoid") then
                    if character.Humanoid:GetState() == Enum.HumanoidStateType.Jumping or character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                        local hrp = character:FindFirstChild("HumanoidRootPart")
                        if hrp then hrp.Velocity = Vector3.new(0, _G.JumpHeight, 0) end
                    end
                end
            end
        end)
    end
})

PlayerTab:CreateToggle({
    Name = "Disable Jump Cooldown",
    CurrentValue = false,
    Flag = "DisableJumpCooldown",
    Callback = function(Value)
        local player = Players.LocalPlayer
        local function disableJumpCooldown(character)
            if character then
                local jumpCooldown = character:FindFirstChild("JumpCooldown")
                if jumpCooldown then
                    jumpCooldown.Disabled = Value
                end
            end
        end
        if player.Character then
            disableJumpCooldown(player.Character)
        end
        player.CharacterAdded:Connect(function(newCharacter)
            task.wait(0.5)
            disableJumpCooldown(newCharacter)
        end)
    end
})


local TransparentBodySection = PlayerTab:CreateSection("Transparent Body")


local TransparentBody = {
    Enabled = false,
    Transparency = 0.7,
    Color = Color3.fromRGB(170, 85, 255), 
    Material = Enum.Material.ForceField,
    OriginalProperties = {}
}


local function UpdateTransparentBody()
    local player = Players.LocalPlayer
    local character = player and player.Character
    if not character then return end
    
    
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            if TransparentBody.Enabled then
                
                if not TransparentBody.OriginalProperties[part] then
                    TransparentBody.OriginalProperties[part] = {
                        Transparency = part.Transparency,
                        Color = part.Color,
                        Material = part.Material
                    }
                end
                
                
                part.Transparency = TransparentBody.Transparency
                part.Color = TransparentBody.Color
                part.Material = TransparentBody.Material
            else
                
                if TransparentBody.OriginalProperties[part] then
                    part.Transparency = TransparentBody.OriginalProperties[part].Transparency
                    part.Color = TransparentBody.OriginalProperties[part].Color
                    part.Material = TransparentBody.OriginalProperties[part].Material
                end
            end
        end
    end
    
    
    local additionalParts = {
        workspace.Camera and workspace.Camera:FindFirstChild("Viewmodel") and workspace.Camera.Viewmodel:FindFirstChild("Left Arm"),
        workspace.Camera and workspace.Camera:FindFirstChild("Viewmodel") and workspace.Camera.Viewmodel:FindFirstChild("Right Arm"),
        workspace:FindFirstChild("larazimhaa") and workspace.larazimhaa:FindFirstChild("Makarov PM")
    }
    
    
    for _, object in pairs(additionalParts) do
        if object then
            
            if object:IsA("BasePart") then
                if TransparentBody.Enabled then
                    
                    if not TransparentBody.OriginalProperties[object] then
                        TransparentBody.OriginalProperties[object] = {
                            Transparency = object.Transparency,
                            Color = object.Color,
                            Material = object.Material
                        }
                    end
                    
                    
                    object.Transparency = TransparentBody.Transparency
                    object.Color = TransparentBody.Color
                    object.Material = TransparentBody.Material
                else
                    
                    if TransparentBody.OriginalProperties[object] then
                        object.Transparency = TransparentBody.OriginalProperties[object].Transparency
                        object.Color = TransparentBody.OriginalProperties[object].Color
                        object.Material = TransparentBody.OriginalProperties[object].Material
                    end
                end
            
            elseif object:IsA("Model") or object:FindFirstChildWhichIsA("BasePart") then
                
                for _, part in pairs(object:GetDescendants()) do
                    if part:IsA("BasePart") then
                        if TransparentBody.Enabled then
                            
                            if not TransparentBody.OriginalProperties[part] then
                                TransparentBody.OriginalProperties[part] = {
                                    Transparency = part.Transparency,
                                    Color = part.Color,
                                    Material = part.Material
                                }
                            end
                            
                            
                            part.Transparency = TransparentBody.Transparency
                            part.Color = TransparentBody.Color
                            part.Material = TransparentBody.Material
                        else
                            
                            if TransparentBody.OriginalProperties[part] then
                                part.Transparency = TransparentBody.OriginalProperties[part].Transparency
                                part.Color = TransparentBody.OriginalProperties[part].Color
                                part.Material = TransparentBody.OriginalProperties[part].Material
                            end
                        end
                    end
                end
            end
        end
    end
    
    
    if TransparentBody.Enabled and not _G.TransparentBodyRenderConnection then
        _G.TransparentBodyRenderConnection = RunService.RenderStepped:Connect(function()
            
            local viewmodel = workspace.Camera and workspace.Camera:FindFirstChild("Viewmodel")
            if viewmodel then
                local leftArm = viewmodel:FindFirstChild("Left Arm")
                local rightArm = viewmodel:FindFirstChild("Right Arm")
                
                for _, arm in pairs({leftArm, rightArm}) do
                    if arm and arm:IsA("BasePart") then
                        if not TransparentBody.OriginalProperties[arm] then
                            TransparentBody.OriginalProperties[arm] = {
                                Transparency = arm.Transparency,
                                Color = arm.Color,
                                Material = arm.Material
                            }
                        end
                        
                        arm.Transparency = TransparentBody.Transparency
                        arm.Color = TransparentBody.Color
                        arm.Material = TransparentBody.Material
                    end
                end
            end
            
            
            local weapon = workspace:FindFirstChild("larazimhaa") and workspace.larazimhaa:FindFirstChild("Makarov PM")
            if weapon then
                for _, part in pairs(weapon:GetDescendants()) do
                    if part:IsA("BasePart") then
                        if not TransparentBody.OriginalProperties[part] then
                            TransparentBody.OriginalProperties[part] = {
                                Transparency = part.Transparency,
                                Color = part.Color,
                                Material = part.Material
                            }
                        end
                        
                        part.Transparency = TransparentBody.Transparency
                        part.Color = TransparentBody.Color
                        part.Material = TransparentBody.Material
                    end
                end
            end
        end)
    elseif not TransparentBody.Enabled and _G.TransparentBodyRenderConnection then
        _G.TransparentBodyRenderConnection:Disconnect()
        _G.TransparentBodyRenderConnection = nil
    end
end


PlayerTab:CreateToggle({
    Name = "Transparent Body",
    CurrentValue = false,
    Flag = "TransparentBodyEnabled",
    Callback = function(Value)
        TransparentBody.Enabled = Value
        
        
        UpdateTransparentBody()
        
        
        if Value then
            
            if _G.TransparentBodyConnection then
                _G.TransparentBodyConnection:Disconnect()
            end
            
            
            _G.TransparentBodyConnection = Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
                
                task.wait(0.5)
                
                UpdateTransparentBody()
            end)
            
        else
            
            if _G.TransparentBodyConnection then
                _G.TransparentBodyConnection:Disconnect()
                _G.TransparentBodyConnection = nil
            end
            
            if _G.TransparentBodyRenderConnection then
                _G.TransparentBodyRenderConnection:Disconnect()
                _G.TransparentBodyRenderConnection = nil
            end
            
            
            TransparentBody.OriginalProperties = {}
        end
    end
})


PlayerTab:CreateSlider({
    Name = "Transparency",
    Range = {0, 0.95},
    Increment = 0.05,
    Suffix = "",
    CurrentValue = TransparentBody.Transparency,
    Flag = "TransparentBodyTransparency",
    Callback = function(Value)
        TransparentBody.Transparency = Value
        
        if TransparentBody.Enabled then
            UpdateTransparentBody()
        end
    end
})


PlayerTab:CreateDropdown({
    Name = "Material",
    Options = {"ForceField", "Glass", "Neon", "SmoothPlastic"},
    CurrentOption = "ForceField",
    Flag = "TransparentBodyMaterial",
    Callback = function(Value)
        if Value == "ForceField" then
            TransparentBody.Material = Enum.Material.ForceField
        elseif Value == "Glass" then
            TransparentBody.Material = Enum.Material.Glass
        elseif Value == "Neon" then
            TransparentBody.Material = Enum.Material.Neon
        elseif Value == "SmoothPlastic" then
            TransparentBody.Material = Enum.Material.SmoothPlastic
        end
        
        
        if TransparentBody.Enabled then
            UpdateTransparentBody()
        end
    end
})


PlayerTab:CreateColorPicker({
    Name = "Color",
    Color = TransparentBody.Color,
    Flag = "TransparentBodyColor",
    Callback = function(Value)
        TransparentBody.Color = Value
        
        if TransparentBody.Enabled then
            UpdateTransparentBody()
        end
    end
})

local TpToolSection = PlayerTab:CreateSection("TpTool")
PlayerTab:CreateButton({
    Name = "TpTool",
    Callback = function()
        local player = Players.LocalPlayer
        local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local tool = Instance.new("Tool", player.Backpack)
            local mouse = player:GetMouse()
            tool.Name = "click tp"
            tool.RequiresHandle = false
            tool.Activated:Connect(function()
                hrp.CFrame = CFrame.new(mouse.Hit.Position + Vector3.new(0,4,0))
            end)
        end
    end
})

local CtrlClickSection = PlayerTab:CreateSection("CtrlClickDelete")
PlayerTab:CreateButton({
    Name = "CtrlClickDelete",
    Callback = function()
        local Mouse = Players.LocalPlayer:GetMouse()
        Mouse.Button1Down:Connect(function()
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) and Mouse.Target then
                Mouse.Target:Destroy()
            end
        end)
    end
})

-- Создаем новую вкладку для настроек автомобиля
local VehicleTab = Window:CreateTab("Car settings", 6022668898)

-- Переносим настройку коллизии
_G.CarCollisionDisabled = false
_G.CarCollisionConnection = nil
_G.CarChildAddedConnections = {}
_G.CarTransparency = 0
_G.CarTransparencyConnection = nil

VehicleTab:CreateSection("Car Collision")
VehicleTab:CreateToggle({
    Name = "No Car Collision [Ramming car mode]",
    CurrentValue = false,
    Flag = "DisableCarBodyCollision",
    Callback = function(Value)
        _G.CarCollisionDisabled = Value
        local playerName = Players.LocalPlayer.Name
        local function findPlayerCar()
    local possibleNames = {
        playerName .. "Car",
        playerName .. "Cars",
        playerName .. "_Car"
    }
    
    for _, name in ipairs(possibleNames) do
        local vehicle = workspace:FindFirstChild(name)
        if vehicle then return vehicle end
    end
    
    for _, obj in pairs(workspace:GetChildren()) do
        if obj:IsA("Model") and (obj.Name:find("Car") or obj.Name:find("car")) and 
           (obj.Name:find(playerName) or obj.Name:find(playerName:lower())) then
            return obj
        end
    end
    
    return nil
end
        -- Оптимизированная функция отключения коллизии
local function applyCollisionSettings(carBody)
    if not carBody then
        carBody = findPlayerCar()
        if not carBody then return false end
    end
    
    local body = carBody:FindFirstChild("Body")
    if not body then
        body = carBody:FindFirstChild("Chassis") or 
               carBody:FindFirstChild("MainBody") or
               carBody:FindFirstChild("Hull") or carBody
    end
    
    if not body then return false end
    
    for _, part in pairs(body:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = not Value
        end
    end
    
    return true
end
        if _G.CarCollisionConnection then
            _G.CarCollisionConnection:Disconnect()
            _G.CarCollisionConnection = nil
        end
        
        for _, conn in pairs(_G.CarChildAddedConnections) do
            if conn then conn:Disconnect() end
        end
        _G.CarChildAddedConnections = {}
        local carBody = findPlayerCar()
        if carBody then
            applyCollisionSettings(carBody)
            local connection = carBody.ChildAdded:Connect(function(child)
                if child.Name == "Body" or child.Name == "Chassis" or child.Name == "MainBody" or child.Name == "Hull" then
                    task.wait(0.5)
                    if _G.CarCollisionDisabled then
                        applyCollisionSettings(carBody)
                    end
                end
            end)
            table.insert(_G.CarChildAddedConnections, connection)
        end
        if Value then
            _G.CarCollisionConnection = workspace.ChildAdded:Connect(function(child)
                if (child.Name:find("Car") or child.Name:find("car")) and 
                   (child.Name:find(playerName) or child.Name:find(playerName:lower())) then
                    task.wait(1)
                    
                    if _G.CarCollisionDisabled then
                        applyCollisionSettings(child)
                        local connection = child.ChildAdded:Connect(function(bodyPart)
                            if bodyPart.Name == "Body" or bodyPart.Name == "Chassis" or 
                               bodyPart.Name == "MainBody" or bodyPart.Name == "Hull" then
                                task.wait(0.5)
                                if _G.CarCollisionDisabled then
                                    applyCollisionSettings(child)
                                end
                            end
                        end)
                        table.insert(_G.CarChildAddedConnections, connection)
                    end
                end
            end)
        end
    end
})
VehicleTab:CreateSection("VehicleFling")

VehicleTab:CreateButton({
    Name = "Fling Car",
    Callback = function()
        local player = Players.LocalPlayer
        if not player then 
            return 
        end

        local character = player.Character
        if not character or not character:FindFirstChildOfClass("Humanoid") then
            return
        end
        
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then
            return
        end

        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid.SeatPart or not humanoid.SeatPart:IsA("VehicleSeat") then
            return
        end

        local vehicleSeat = humanoid.SeatPart
        local vehicleToFling = nil
        local vehicleModel = vehicleSeat:FindFirstAncestorWhichIsA("Model")

        if vehicleModel then
            if vehicleModel.PrimaryPart and vehicleModel.PrimaryPart:IsA("BasePart") then
                vehicleToFling = vehicleModel.PrimaryPart
            else
                local mainPartNames = {"Chassis", "Body", "DriveSeat", "Main", "Frame"}
                for _, nameKey in ipairs(mainPartNames) do
                    local potentialPart = vehicleModel:FindFirstChild(nameKey, true) 
                    if potentialPart and potentialPart:IsA("BasePart") then
                        vehicleToFling = potentialPart
                        break
                    end
                end
                if not vehicleToFling then
                    for _, partDescendant in ipairs(vehicleModel:GetDescendants()) do
                        if partDescendant:IsA("BasePart") and partDescendant ~= vehicleSeat and partDescendant.Name ~= "HumanoidRootPart" then
                            vehicleToFling = partDescendant
                            break
                        end
                    end
                end
            end
        end
        
        if not vehicleToFling and vehicleSeat.Parent and vehicleSeat.Parent:IsA("BasePart") and vehicleSeat.Parent ~= character then
            vehicleToFling = vehicleSeat.Parent
        end

        if not vehicleToFling and vehicleSeat:IsA("BasePart") then
            vehicleToFling = vehicleSeat
        end

        if not vehicleToFling or not vehicleToFling:IsA("BasePart") then
            return
        end
        if vehicleToFling.Parent then
        end
        local upwardVelocity = 200  
        local forwardVelocity = 150 
        local lookVector = humanoidRootPart.CFrame.LookVector
        local flingVelocity = Vector3.new(lookVector.X * forwardVelocity, upwardVelocity, lookVector.Z * forwardVelocity)
        vehicleToFling.AssemblyLinearVelocity = flingVelocity
    end
})
local carSpeedEnabled = false
local carSpeedFactor = 1.0 
local carSpeedLoop = nil
local lastVehicleSpeed = 0 

VehicleTab:CreateSection("Vehicle Speed Control")

local function findChassisTune(vehicleModel)
    if not vehicleModel then return nil end

    local tuneScript = vehicleModel:FindFirstChild("A-Chassis Tune", true)
    if tuneScript then
        if tuneScript:IsA("ModuleScript") then
            local success, tuneConfig = pcall(require, tuneScript)
            if success and type(tuneConfig) == "table" and tuneConfig.SteerInner and tuneConfig.SteerOuter then
                return tuneConfig 
            end
        end

        if tuneScript.SteerInner and tuneScript.SteerOuter then
            return tuneScript 
        end
    end
    
    local steerInnerValue = vehicleModel:FindFirstChild("SteerInner", true)
    local steerOuterValue = vehicleModel:FindFirstChild("SteerOuter", true)

    if steerInnerValue and steerInnerValue:IsA("ValueBase") and 
       steerOuterValue and steerOuterValue:IsA("ValueBase") then
        return { SteerInner = steerInnerValue, SteerOuter = steerOuterValue }
    end
    
    return nil
end


local function applySteeringAngle(value)
    local player = Players.LocalPlayer
    local character = player and player.Character
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.SeatPart and humanoid.SeatPart:IsA("VehicleSeat") then
        local vehicleSeat = humanoid.SeatPart
        local vehicleModel = vehicleSeat:FindFirstAncestorWhichIsA("Model")
        if not vehicleModel then return end
        local tuneConfig = findChassisTune(vehicleModel)
        if not tuneConfig then return end
        if not _G.OriginalSteerSettings then
            _G.OriginalSteerSettings = {}
            if type(tuneConfig.SteerInner) == "number" then
                _G.OriginalSteerSettings.SteerInner = tuneConfig.SteerInner
                _G.OriginalSteerSettings.SteerOuter = tuneConfig.SteerOuter
            elseif tuneConfig.SteerInner:IsA("ValueBase") then
                _G.OriginalSteerSettings.SteerInner = tuneConfig.SteerInner.Value
                _G.OriginalSteerSettings.SteerOuter = tuneConfig.SteerOuter.Value
            end
        end
        local clampedValue = math.clamp(value, 0, 90)
        if type(tuneConfig.SteerInner) == "number" then
            tuneConfig.SteerInner = clampedValue
            tuneConfig.SteerOuter = clampedValue
        elseif tuneConfig.SteerInner:IsA("ValueBase") then
            tuneConfig.SteerInner.Value = clampedValue
            tuneConfig.SteerOuter.Value = clampedValue
        end
    elseif _G.OriginalSteerSettings then
        local vehicleModel = character and character:FindFirstAncestorWhichIsA("Model")
        local tuneConfig = vehicleModel and findChassisTune(vehicleModel)
        
        if tuneConfig then
            if type(tuneConfig.SteerInner) == "number" then
                tuneConfig.SteerInner = _G.OriginalSteerSettings.SteerInner
                tuneConfig.SteerOuter = _G.OriginalSteerSettings.SteerOuter
            elseif tuneConfig.SteerInner:IsA("ValueBase") then
                tuneConfig.SteerInner.Value = _G.OriginalSteerSettings.SteerInner
                tuneConfig.SteerOuter.Value = _G.OriginalSteerSettings.SteerOuter
            end
        end
        _G.OriginalSteerSettings = nil
    end
end

VehicleTab:CreateSlider({
    Name = "Wheel Rotation Angle",
    Range = {0, 90}, 
    Increment = 1,
    Suffix = "°",
    CurrentValue = 40, 
    Flag = "SteeringAngle",
    Callback = function(Value)
        applySteeringAngle(Value)
    end
})

local function findVehicleBoostPart(vehicleSeat, character)
    local vehicleModel = vehicleSeat:FindFirstAncestorWhichIsA("Model")
    if vehicleModel then
        if vehicleModel.PrimaryPart and vehicleModel.PrimaryPart:IsA("BasePart") then
            return vehicleModel.PrimaryPart
        end
        
        local mainPartNames = {"Chassis", "Body", "Frame", "DriveSeat"}
        for _, nameKey in ipairs(mainPartNames) do
            local part = vehicleModel:FindFirstChild(nameKey, true)
            if part and part:IsA("BasePart") then return part end
        end
        
        for _, part in ipairs(vehicleModel:GetDescendants()) do
            if part:IsA("BasePart") and part ~= vehicleSeat and 
               part.Name ~= "HumanoidRootPart" and part.AssemblyMass > 5 then
                return part
            end
        end
    end
    
    if vehicleSeat.Parent and vehicleSeat.Parent:IsA("BasePart") and 
       vehicleSeat.Parent ~= character then
        return vehicleSeat.Parent
    end
    
    if vehicleSeat:IsA("BasePart") then return vehicleSeat end
    
    return nil
end

VehicleTab:CreateToggle({
    Name = "Enable Car Accelerator", 
    CurrentValue = false,
    Flag = "CarSpeedhackEnabled", 
    Callback = function(Value)
        carSpeedEnabled = Value
        if carSpeedEnabled then
            if carSpeedLoop then carSpeedLoop:Disconnect() end

            carSpeedLoop = RunService.Heartbeat:Connect(function()
                if not carSpeedEnabled then return end

                local player = Players.LocalPlayer
                local char = player and player.Character
                if not (char and char.Parent) then return end
                local hum = char:FindFirstChildOfClass("Humanoid")
                if not (hum and hum.Parent) then return end

                if hum.SeatPart and hum.SeatPart:IsA("VehicleSeat") then
                    local vehicleSeat = hum.SeatPart
                    local vehiclePartToBoost = findVehicleBoostPart(vehicleSeat, char)

                    if vehiclePartToBoost and vehiclePartToBoost:IsA("BasePart") and not vehiclePartToBoost.Anchored then
                        local forwardVector = vehicleSeat.CFrame.LookVector 
                        local throttle = vehicleSeat.ThrottleFloat 
                        
                        if throttle ~= 0 then 
                            local boostStrength = 75 
                            local additionalVelocity = forwardVector * boostStrength * carSpeedFactor * throttle * (RunService.Heartbeat:Wait()) 
                            
                            vehiclePartToBoost.AssemblyLinearVelocity = vehiclePartToBoost.AssemblyLinearVelocity + additionalVelocity
                           
                            local dynamicMaxSpeed = 200 + (150 * carSpeedFactor) 
                            if vehiclePartToBoost.AssemblyLinearVelocity.Magnitude > dynamicMaxSpeed then
                                vehiclePartToBoost.AssemblyLinearVelocity = vehiclePartToBoost.AssemblyLinearVelocity.Unit * dynamicMaxSpeed
                            end
                        end
                        lastVehicleSpeed = vehiclePartToBoost.AssemblyLinearVelocity.Magnitude
                    end
                else
                    lastVehicleSpeed = 0
                end
            end)

        else
            if carSpeedLoop then
                carSpeedLoop:Disconnect()
                carSpeedLoop = nil
            end
            lastVehicleSpeed = 0
        end
    end
})

VehicleTab:CreateSlider({
    Name = "Car Acceleration Factor", 
    Range = {1, 10}, 
    Increment = 0.5,
    Suffix = "x",
    CurrentValue = 1.0,
    Flag = "CarSpeedFactorValue", 
    Callback = function(Value)
        carSpeedFactor = Value
        if carSpeedEnabled then 
        end
    end
})

local WorldTab = Window:CreateTab("World", 7734068321)
local MapSection = WorldTab:CreateSection("Map")
WorldTab:CreateButton({
    Name = "Full Bright",
    Callback = function()
        if not _G.FullBrightExecuted then
            _G.FullBrightEnabled = false
            _G.NormalLightingSettings = {
                Brightness = Lighting.Brightness,
                ClockTime = Lighting.ClockTime,
                FogEnd = Lighting.FogEnd,
                GlobalShadows = Lighting.GlobalShadows,
                Ambient = Lighting.Ambient,
                OutdoorAmbient = Lighting.OutdoorAmbient,
                FogStart = Lighting.FogStart
            }
            _G.FullBrightExecuted = true
            
            
            _G.FullBrightConnections = {}
        end
        
        _G.FullBrightEnabled = not _G.FullBrightEnabled
        
        if _G.FullBrightEnabled then
            
            if _G.FullBrightConnections then
                for _, connection in pairs(_G.FullBrightConnections) do
                    if connection then connection:Disconnect() end
                end
                _G.FullBrightConnections = {}
            end
            
            
            local function applyFullBrightSettings()
                
                Lighting.Brightness = 2
                Lighting.GlobalShadows = false
                Lighting.Ambient = Color3.fromRGB(199, 199, 199)
                Lighting.OutdoorAmbient = Color3.fromRGB(199, 199, 199)
                
                
                Lighting.ClockTime = 14 
                Lighting.FogEnd = 786543 
                Lighting.FogStart = 0
                
                
                for _, v in pairs(Lighting:GetChildren()) do
                    if v:IsA("BlurEffect") or v:IsA("ColorCorrectionEffect") or 
                       v:IsA("BloomEffect") or v:IsA("SunRaysEffect") then
                        v.Enabled = false
                    end
                end
            end
            
            
            applyFullBrightSettings()
            
            
            table.insert(_G.FullBrightConnections, RunService.RenderStepped:Connect(applyFullBrightSettings))
            
            
            
            local properties = {
                "Brightness", "GlobalShadows", "Ambient", "OutdoorAmbient", 
                "ClockTime", "FogEnd", "FogStart"
            }
            
            for _, property in ipairs(properties) do
                table.insert(_G.FullBrightConnections, 
                    Lighting:GetPropertyChangedSignal(property):Connect(function()
                        
                        
                        if _G.FullBrightEnabled then
                            if property == "Brightness" and Lighting.Brightness ~= 2 then
                                Lighting.Brightness = 2
                            elseif property == "GlobalShadows" and Lighting.GlobalShadows ~= false then
                                Lighting.GlobalShadows = false
                            elseif property == "Ambient" and Lighting.Ambient ~= Color3.fromRGB(199, 199, 199) then
                                Lighting.Ambient = Color3.fromRGB(199, 199, 199)
                            elseif property == "OutdoorAmbient" and Lighting.OutdoorAmbient ~= Color3.fromRGB(199, 199, 199) then
                                Lighting.OutdoorAmbient = Color3.fromRGB(199, 199, 199)
                            elseif property == "ClockTime" and Lighting.ClockTime ~= 14 then
                                Lighting.ClockTime = 14
                            elseif property == "FogEnd" and Lighting.FogEnd ~= 786543 then
                                Lighting.FogEnd = 786543
                            elseif property == "FogStart" and Lighting.FogStart ~= 0 then
                                Lighting.FogStart = 0
                            end
                        end
                    end)
                )
            end
            
            
            table.insert(_G.FullBrightConnections, RunService.Heartbeat:Connect(applyFullBrightSettings))
            
            
        else
            
            if _G.FullBrightConnections then
                for _, connection in pairs(_G.FullBrightConnections) do
                    if connection then connection:Disconnect() end
                end
                _G.FullBrightConnections = {}
            end
            
            
            for setting, value in pairs(_G.NormalLightingSettings) do
                pcall(function() Lighting[setting] = value end)
            end
            
            
            for _, v in pairs(Lighting:GetChildren()) do
                if v:IsA("BlurEffect") or v:IsA("ColorCorrectionEffect") or 
                   v:IsA("BloomEffect") or v:IsA("SunRaysEffect") then
                    v.Enabled = true
                end
            end
        end
    end
})

WorldTab:CreateButton({
    Name = "Remove Foliage",
    Callback = function()
        local function cleanTrees()
            local treesFolder = Workspace:FindFirstChild("Trees")
            if treesFolder then treesFolder:Destroy() end
            local mapFolder = Workspace:FindFirstChild("map")
            if mapFolder then
                local mapTreesFolder = mapFolder:FindFirstChild("Trees")
                if mapTreesFolder then mapTreesFolder:Destroy() end
                local leafFolder = mapFolder:FindFirstChild("Leaf")
                if leafFolder then leafFolder:Destroy() end
                for _, model in ipairs(mapFolder:GetChildren()) do
                    if model:IsA("Model") and model.Name == "Tree" then
                        model:Destroy()
                    end
                end
            end
            for _, obj in ipairs(Workspace:GetChildren()) do
                if obj:IsA("Model") and obj.Name == "Tree" then
                    obj:Destroy()
                end
            end
        end
        cleanTrees()
    end
})

WorldTab:CreateButton({
    Name = "Remove Fog",
    Callback = function()
        for _, child in ipairs(Lighting:GetChildren()) do
            if child.ClassName ~= "ColorCorrection" and child.ClassName ~= "BloomEffect" and child.ClassName ~= "BlurEffect" and child.ClassName ~= "SunRaysEffect" then
                
                if child:IsA("Atmosphere") or child.Name == "Fog" or child:IsA("Sky") then
                    child:Destroy()
                end
            end
        end
        
        Lighting.FogEnd = 1000000
        Lighting.FogStart = 0
        Lighting.FogColor = Color3.fromRGB(192, 192, 192) 

        
        local atmosphere = Lighting:FindFirstChildOfClass("Atmosphere")
        if atmosphere then
            atmosphere.Haze = 0
            atmosphere.Density = 0
        end
    end
})

local OtherSection = WorldTab:CreateSection("Other")
WorldTab:CreateButton({
    Name = "Fps boost",
    Callback = function()
        local decalsyeeted = true
        sethiddenproperty(Lighting, "Technology", 2)
        local Terrain = Workspace.Terrain
        sethiddenproperty(Terrain, "Decoration", false)
        Terrain.WaterWaveSize     = 0
        Terrain.WaterWaveSpeed    = 0
        Terrain.WaterReflectance  = 0
        Terrain.WaterTransparency = 0
        Lighting.GlobalShadows    = false
        Lighting.FogEnd           = 9e9
        Lighting.Brightness       = 0
        settings().Rendering.QualityLevel = "Level01"
        for _, v in ipairs(Workspace:GetDescendants()) do
            if v:IsA("BasePart") and not v:IsA("MeshPart") then
                v.Material = "Plastic"
                v.Reflectance = 0
            elseif (v:IsA("Decal") or v:IsA("Texture")) and decalsyeeted then
                v.Transparency = 1
            elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
                v.Lifetime = NumberRange.new(0)
            elseif v:IsA("Explosion") then
                v.BlastPressure = 1
                v.BlastRadius   = 1
            elseif v:IsA("Fire") or v:IsA("SpotLight") or v:IsA("Smoke") or v:IsA("Sparkles") then
                v.Enabled = false
            elseif v:IsA("MeshPart") and decalsyeeted then
                v.Material = "Plastic"
                v.Reflectance = 0
                v.TextureID = 10385902758728957
            end
        end
    end
})

WorldTab:CreateToggle({
    Name = "RTX",
    CurrentValue = false,
    Flag = "RTXEnabled",
    Callback = function(Value)
        if Value then
            Lighting.Technology = Enum.Technology.Future
            Lighting.Ambient = Color3.fromRGB(25, 25, 25)
            Lighting.OutdoorAmbient = Color3.fromRGB(25, 25, 25)
            Lighting.ShadowSoftness = 0.1
            Lighting.EnvironmentDiffuseScale = 0.7
            Lighting.EnvironmentSpecularScale = 0.7
            
        else
            Lighting.Technology = Enum.Technology.ShadowMap
            Lighting.Ambient = Color3.fromRGB(70, 70, 70)
            Lighting.OutdoorAmbient = Color3.fromRGB(0, 0, 0)
            Lighting.ShadowSoftness = 0
            Lighting.EnvironmentDiffuseScale = 1
            Lighting.EnvironmentSpecularScale = 0.425
            
        end
    end
})

local MiscTab = Window:CreateTab("Misc", 4384401360)


local InfiniteYieldSection = MiscTab:CreateSection("Infinite Yield")
MiscTab:CreateButton({
    Name = "Infinite Yield",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
    end
})
local ServerSection = MiscTab:CreateSection("Server")
MiscTab:CreateButton({
    Name = "Reconnect",
    Callback = function()

        task.wait(1)
        local player = Players.LocalPlayer
        local success, errorMsg = pcall(function()
            if game.JobId == "" then
                TeleportService:Teleport(game.PlaceId, player)
            else
                TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
            end
        end)
        if success then

        else
            task.wait(1)
            task.wait(1)
            pcall(function()
                TeleportService:Teleport(game.PlaceId)
            end)
        end
    end
})

local modelName = "PyaterochkaPortal"
local model = Workspace:FindFirstChild(modelName)
if model then
    model:Destroy()
end
local mapFolder = Workspace:FindFirstChild("map")
if mapFolder then
    local texturesFolder = mapFolder:FindFirstChild("Textures_Overlay")
    if texturesFolder then texturesFolder:Destroy() end
end


local function handleCharacterRespawnForWeaponMods(character)
    task.wait(2) 

    local player = Players.LocalPlayer
    if not player then return end
    
    local playerName = player.Name
    if not playerName then return end

    
    local function attemptToApplyWeaponMods()
        
        local currentWeaponsFolder = workspace:FindFirstChild(playerName)
        if not currentWeaponsFolder then 
            return false 
        end

        
        local hasWeapon = false
        for _, obj in pairs(currentWeaponsFolder:GetChildren()) do
            if obj:FindFirstChild("GunScript_Local") then
                hasWeapon = true
                break
            end
        end

        if not hasWeapon then
            return false 
        end

        
        weaponsFolder = currentWeaponsFolder
        weaponsFolderBallistics = currentWeaponsFolder 
        weaponsFolderReload = currentWeaponsFolder
        
        
        setupBallisticsWatcher()
        setupReloadWatcher()
        
        
        if NO_RECOIL_ENABLED then
            if _G.NoRecoilConnection then
                _G.NoRecoilConnection:Disconnect()
                _G.NoRecoilConnection = nil
            end
            
            _G.NoRecoilConnection = weaponsFolder.ChildAdded:Connect(function()
                task.wait(0.2)
                patchAllGuns()
            end)
        end
        
        
        if NO_RECOIL_ENABLED then patchAllGuns() end
        if NO_BALLISTIC_ENABLED then patchBallistics() end
        if INSTANT_RELOAD_ENABLED then patchInstantReloadAndDisableAnim() end
        
        return true 
    end
    
    
    task.spawn(function()
        local success = false
        local attempts = 0
        local maxAttempts = 5
        
        
        repeat
            attempts = attempts + 1
            success = attemptToApplyWeaponMods()
            
            if not success and attempts < maxAttempts then
                task.wait(1) 
            end
        until success or attempts >= maxAttempts
        
        if success then

        else

        end
    end)
end


Players.LocalPlayer.CharacterAdded:Connect(handleCharacterRespawnForWeaponMods)


game:GetService("UserInputService").InputBegan:Connect(function(input, gpe)
    if not gpe and input.KeyCode == Enum.KeyCode.F7 then
        
        if Players.LocalPlayer.Character then

            handleCharacterRespawnForWeaponMods(Players.LocalPlayer.Character)
        end
    end
end)


do
    
    local AUTO_WEAPON_CHANGE_DETECTION = true 
    local CHECK_INTERVAL = 3.0 
    
    local lastActiveWeapon = nil
    local lastCheckTime = 0 
    
    
    local function getActiveWeapon()
        local player = Players.LocalPlayer
        if not player or not player.Character then return nil end
        
        
        for _, tool in ipairs(player.Character:GetChildren()) do
            if tool:IsA("Tool") and tool:FindFirstChild("GunScript_Local") then
                return {
                    tool = tool,
                    name = tool.Name,
                    id = tool:GetAttribute("WeaponID") or tool:GetAttribute("ID") or tool.Name 
                }
            end
        end
        
        return nil 
    end
    
    
    local function applyAllActiveWeaponMods()
        
        local modsToApply = {}
        if NO_RECOIL_ENABLED then table.insert(modsToApply, "NoRecoil") end
        if NO_BALLISTIC_ENABLED then table.insert(modsToApply, "InstantHit") end
        if INSTANT_RELOAD_ENABLED then table.insert(modsToApply, "InstantReload") end
        
        
        if #modsToApply == 0 then return end
        
        
        for _, mod in ipairs(modsToApply) do
            if mod == "NoRecoil" then
                pcall(patchAllGuns)
            elseif mod == "InstantHit" then
                pcall(patchBallistics)
            elseif mod == "InstantReload" then
                pcall(patchInstantReloadAndDisableAnim)
            end
            
            
            task.wait(0.05)
        end
    end
    
    
    local function checkWeaponChange()
        
        if not AUTO_WEAPON_CHANGE_DETECTION then return end
        
        
        local currentTime = tick()
        if currentTime - lastCheckTime < 0.5 then return end 
        lastCheckTime = currentTime
        
        local currentWeapon = getActiveWeapon()
        
        
        if not lastActiveWeapon and currentWeapon then
            lastActiveWeapon = currentWeapon
            task.spawn(applyAllActiveWeaponMods) 
            return
        end
        
        
        local weaponChanged = false
        
        if (lastActiveWeapon and not currentWeapon) or 
           (not lastActiveWeapon and currentWeapon) then
            weaponChanged = true 
        elseif lastActiveWeapon and currentWeapon and lastActiveWeapon.id ~= currentWeapon.id then
            weaponChanged = true 
        end
        
        if weaponChanged then
            
            lastActiveWeapon = currentWeapon
            
            
            if currentWeapon then
                task.spawn(function()
                    task.wait(0.3) 
                    applyAllActiveWeaponMods()
                end)
            end
        end
    end
    
    
    game:GetService("UserInputService").InputBegan:Connect(function(input, gpe)
        if not gpe and input.KeyCode == Enum.KeyCode.F8 then
            AUTO_WEAPON_CHANGE_DETECTION = not AUTO_WEAPON_CHANGE_DETECTION
        end
    end)
    
    
    if not _G.WeaponChangeChecker then
        _G.WeaponChangeChecker = task.spawn(function()
            while true do
                task.wait(CHECK_INTERVAL) 
                
                local success, err = pcall(function()
                    checkWeaponChange()
                end)
                
                if not success and not _G.WeaponChangeErrorNotified then
                    
                    _G.WeaponChangeErrorNotified = true
                    
                    task.delay(10, function()
                        _G.WeaponChangeErrorNotified = false 
                    end)
                end
            end
        end)
    end
end



local function CreateBillboardESP(part, folder)
    if not part then return nil end
    
    
    local espObject = {
        Part = part,
        Gui = nil,
        Label = nil
    }
    
    
    local success, result = pcall(function()
        local gui = Instance.new("BillboardGui")
        gui.Name = "DropESP_" .. part.Name
        gui.AlwaysOnTop = true
        gui.Size = UDim2.new(0, 200, 0, 50) 
        gui.StudsOffset = Vector3.new(0, 2, 0)
        gui.Adornee = part
        gui.MaxDistance = DropESP.MaxDistance
        
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 0.5, 0)
        label.Position = UDim2.new(0, 0, 0, 0)
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.fromRGB(255, 0, 0) 
        label.TextStrokeTransparency = 0 
        label.TextStrokeColor3 = Color3.new(0, 0, 0)
        label.TextSize = 18 
        label.Font = Enum.Font.SourceSansBold
        label.Text = "Box[0m]"
        label.Parent = gui
        
        gui.Parent = folder
        
        return {
            Gui = gui,
            Label = label
        }
    end)
    
    if success then
        espObject.Gui = result.Gui
        espObject.Label = result.Label
        return espObject
    else
        return nil
    end
end


local function UpdateBillboardESP(espObject)
    if not espObject or not espObject.Part or not espObject.Part.Parent or not espObject.Gui then
        return false
    end
    
    local success = pcall(function()
        
        espObject.Gui.Enabled = DropESP.Enabled
        
        
        local player = Players.LocalPlayer
        local character = player and player.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
        
        if humanoidRootPart then
            local distance = (humanoidRootPart.Position - espObject.Part.Position).Magnitude
            espObject.Label.Text = string.format("box[%dm]", math.floor(distance))
            
            
            if distance > DropESP.MaxDistance then
                espObject.Gui.Enabled = false
            end
        end
    end)
    
    return success
end


local function RemoveBillboardESP(espObject)
    if espObject and espObject.Gui then
        pcall(function()
            espObject.Gui:Destroy()
        end)
    end
end


function DropESPManager:CreateObject(dropPart)
    if not dropPart then return end
    
    if self.Objects[dropPart] then
        pcall(function() self:RemoveObject(dropPart) end)
    end
    
    if DropESP.UseDrawing then
        
        local espObject = DropESPObject.new(dropPart)
        if espObject then
            self.Objects[dropPart] = {
                Type = "Drawing",
                Object = espObject
            }
        end
    else
        
        local folder = _G.DropESPFolder
        
        if not folder or not folder.Parent then
            folder = Instance.new("Folder")
            folder.Name = "DropESPFolder"
            
            
            local success = pcall(function()
                folder.Parent = game:GetService("CoreGui")
            end)
            
            if not success then
                pcall(function()
                    folder.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
                end)
            end
            
            _G.DropESPFolder = folder
        end
        
        local espObject = CreateBillboardESP(dropPart, folder)
        if espObject then
            self.Objects[dropPart] = {
                Type = "BillboardGui",
                Object = espObject
            }
        end
    end
end

function DropESPManager:UpdateAll()
    
    if DropESP.Enabled and not DropESP.TargetFolder then
        DropESP.TargetFolder = FindDropFolder()
    end
    
    
    for part, objData in pairs(self.Objects) do
        if part and part.Parent then
            if objData.Type == "Drawing" and objData.Object then
                objData.Object:Update()
            elseif objData.Type == "BillboardGui" and objData.Object then
                if not UpdateBillboardESP(objData.Object) then
                    self:RemoveObject(part)
                end
            end
        else
            self:RemoveObject(part)
        end
    end
    
    
    if DropESP.Enabled and DropESP.TargetFolder then
        for _, model in pairs(DropESP.TargetFolder:GetChildren()) do
            if model:IsA("Model") then
                local mainPart = GetModelMainPart(model)
                if mainPart and not self.Objects[mainPart] then
                    self:CreateObject(mainPart)
                end
            end
        end
    end
end

function DropESPManager:RemoveObject(dropPart)
    if not dropPart or not self.Objects[dropPart] then return end
    
    local objData = self.Objects[dropPart]
    if objData.Type == "Drawing" and objData.Object then
        pcall(function() objData.Object:Remove() end)
    elseif objData.Type == "BillboardGui" and objData.Object then
        RemoveBillboardESP(objData.Object)
    end
    
    self.Objects[dropPart] = nil
end

function DropESPManager:ClearAllObjects()
    for part, _ in pairs(self.Objects) do
        self:RemoveObject(part)
    end
    
    
    if _G.DropESPFolder then
        pcall(function()
            _G.DropESPFolder:Destroy()
            _G.DropESPFolder = nil
        end)
    end
end


task.spawn(function()
    
    task.wait(1)
    
    
    local success, result = pcall(function()
        return FindDropFolder()
    end)
    
    if success and result then
        DropESP.TargetFolder = result
    end
end)

local localPlayer = Players.LocalPlayer

local function ResizeAndTransparentizeHead(newPlayer)
    if not HeadHitboxSettings.Enabled then return end
    local character = newPlayer.Character
    if not character then return end
    local head = character:FindFirstChild("Head")
    if not head or not head:IsA("BasePart") then return end
    
    pcall(function()
        head.Size = Vector3.new(HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize, HeadHitboxSettings.HeadSize)
        head.Transparency = HeadHitboxSettings.OthersTransparency
        if not head:FindFirstChild("RAILhubHeadModified") then
            local marker = Instance.new("StringValue")
            marker.Name = "RAILhubHeadModified"
            marker.Value = "true"
            marker.Parent = head
        end
    end)
end


Rayfield:Notify({
    Title = "Welcome, " .. localPlayer.Name .. "!",
    Content = "Join our discord or telegram for updates!",
    Duration = 10,
    Image = 4483345998
})

function PickUpNearestBox()
    local Player = game:GetService("Players").LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
    local Humanoid = Character:WaitForChild("Humanoid")
    
    local function isVisible(targetPosition)
        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {Character}
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        local direction = (targetPosition - HumanoidRootPart.Position)
        local result = workspace:Raycast(HumanoidRootPart.Position, direction, raycastParams)
        return not result or result.Instance:IsDescendantOf(workspace)
    end
    
    local function waitForReachTarget(targetPosition, timeout)
        local startTime = tick()
        local lastDistance = math.huge
        local stuckCounter = 0
        
        while tick() - startTime < timeout do
            local currentDistance = (HumanoidRootPart.Position - targetPosition).Magnitude
            
            if currentDistance <= 5 then
                return true
            end
            
            if math.abs(lastDistance - currentDistance) < 0.1 then
                stuckCounter = stuckCounter + 1
                if stuckCounter >= 5 then
                    break
                end
            else
                stuckCounter = 0
            end
            
            lastDistance = currentDistance
            wait(0.2)
        end
        
        return false
    end
    
    wait(1) -- Начальная задержка
    
    local closestPrompt = nil
    local closestDistance = math.huge
    local promptPosition = nil
    
    for _, prompt in ipairs(workspace:GetDescendants()) do
        if prompt:IsA("ProximityPrompt") and prompt.Enabled then
            local promptParent = prompt.Parent
            local promptPos = promptParent and promptParent:IsA("BasePart") and promptParent.Position
            
            if promptPos then
                local distance = (HumanoidRootPart.Position - promptPos).Magnitude
                
                if distance <= prompt.MaxActivationDistance * 2 and isVisible(promptPos) and distance < closestDistance then
                    closestDistance = distance
                    closestPrompt = prompt
                    promptPosition = promptPos
                end
            end
        end
    end
    
    if not closestPrompt then
        return false
    end
    
    if closestDistance > 5 then
        local reached = waitForReachTarget(promptPosition, 5)
        if not reached then
            return false
        end
    end
    
    wait(2) -- Дополнительная задержка после приземления
    
    -- Повторная проверка дистанции после ожидания
    local finalDistance = (HumanoidRootPart.Position - promptPosition).Magnitude
    if finalDistance > closestPrompt.MaxActivationDistance then
        return false
    end
    
    local success = false
    local attempts = 0
    
    while not success and attempts < 5 do
        attempts = attempts + 1
        
        -- Активация промпта через FireServer (более надежный метод)
        local oldTriggerEvent = closestPrompt.Triggered:Connect(function() 
            success = true 
        end)
        
        -- Более агрессивное зажимание кнопки
        closestPrompt:InputHoldBegin()
        
        if closestPrompt.HoldDuration > 0 then
            -- Для промптов с удержанием удерживаем кнопку дольше, чем требуется
            for i = 1, 3 do
                wait(closestPrompt.HoldDuration / 3)
                -- Повторно отправляем сигнал удержания для надежности
                closestPrompt:InputHoldBegin()
            end
            wait(0.5)
        else
            -- Для мгновенных промптов делаем несколько попыток
            for i = 1, 3 do
                wait(0.1)
                closestPrompt:InputHoldBegin()
            end
            wait(0.3)
        end
        
        closestPrompt:InputHoldEnd()
        
        if success then
            oldTriggerEvent:Disconnect()
            break
        end
        
        oldTriggerEvent:Disconnect()
        wait(0.5)
        
        -- Проверка, была ли коробка подобрана
        local newPrompts = {}
        for _, prompt in ipairs(workspace:GetDescendants()) do
            if prompt:IsA("ProximityPrompt") and prompt.Enabled and prompt.Parent and prompt.Parent:IsA("BasePart") then
                table.insert(newPrompts, prompt)
            end
        end
        
        local stillExists = false
        for _, prompt in ipairs(newPrompts) do
            if prompt == closestPrompt then
                stillExists = true
                break
            end
        end
        
        if not stillExists then
            success = true
            wait(1) -- Ожидание после успешного подбора коробки
            break
        end
        
        wait(0.5)
    end
    
    return success
end

function TryPickUpMultipleTimes(attempts)
    attempts = attempts or 3
    for i = 1, attempts do
        if PickUpNearestBox() then
            return true
        end
        wait(0.3)
    end
    return false
end
